<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Life OS - Command Center</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Orbitron:wght@400;700;900&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00d4ff;
            --secondary: #0099ff;
            --accent: #ff006e;
            --success: #00ff88;
            --warning: #ffaa00;
            --bg-dark: #0a0e27;
            --bg-darker: #050810;
            --text-primary: #e0f7ff;
            --text-secondary: #7dd3fc;
            --glow-primary: 0 0 20px rgba(0, 212, 255, 0.3);
            --glow-accent: 0 0 20px rgba(255, 0, 110, 0.3);
        }

        /* Light Theme */
        body.light-theme {
            --primary: #0066cc;
            --secondary: #0099ff;
            --accent: #cc0066;
            --success: #009900;
            --warning: #ff9900;
            --bg-dark: #f5f5f5;
            --bg-darker: #ffffff;
            --text-primary: #1a1a1a;
            --text-secondary: #666666;
            --glow-primary: 0 0 20px rgba(0, 102, 204, 0.15);
            --glow-accent: 0 0 20px rgba(204, 0, 102, 0.15);
        }

        /* Light Theme - Sidebar Tabs */
        body.light-theme .sidebar-tab-btn {
            color: var(--text-secondary);
            border-bottom-color: transparent;
        }

        body.light-theme .sidebar-tab-btn:hover {
            background: rgba(0, 102, 204, 0.08);
            color: var(--primary);
        }

        body.light-theme .sidebar-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(0, 102, 204, 0.12);
        }

        /* Light Theme - Left Sidebar */
        body.light-theme #leftSidebar {
            background: rgba(0, 102, 204, 0.05);
            border-color: rgba(0, 102, 204, 0.2);
        }

        /* Light Theme - Module List Item */
        body.light-theme .module-list-item {
            background: rgba(0, 102, 204, 0.1) !important;
            border-color: rgba(0, 102, 204, 0.2) !important;
        }

        body.light-theme .module-list-item:hover {
            background: rgba(0, 102, 204, 0.2) !important;
            border-color: rgba(0, 102, 204, 0.3) !important;
        }

        body.light-theme body::before {
            opacity: 0.1;
        }

        body {
            font-family: 'Space Mono', monospace;
            background: radial-gradient(ellipse at 50% 0%, rgba(0, 99, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(ellipse at 0% 50%, rgba(0, 212, 255, 0.05) 0%, transparent 50%),
                        var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 212, 255, 0.02) 0px,
                    rgba(0, 212, 255, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                );
            pointer-events: none;
            z-index: -1;
            opacity: 0.5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 60px;
            animation: fadeInDown 0.8s ease-out;
            position: relative;
        }

        .theme-toggle {
            position: absolute;
            top: 0;
            right: 0;
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 8px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-weight: 600;
        }

        .theme-toggle:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        h1 {
            font-family: 'Orbitron', monospace;
            font-size: 3.5rem;
            font-weight: 900;
            letter-spacing: 3px;
            margin-bottom: 10px;
            background: linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-transform: uppercase;
            text-shadow: 0 0 40px rgba(0, 212, 255, 0.3);
            filter: drop-shadow(0 0 20px rgba(0, 212, 255, 0.2));
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-top: 10px;
            animation: fadeInUp 0.8s ease-out 0.2s both;
        }

        .status-line {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            font-size: 0.85rem;
            letter-spacing: 1px;
            animation: fadeInUp 0.8s ease-out 0.4s both;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--success);
            border-radius: 50%;
            box-shadow: var(--glow-primary);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* View Modes */
        .view-container {
            animation: fadeIn 0.6s ease-out;
        }

        .hidden-view {
            display: none;
        }

        /* Dashboard Overview Grid */
        .overview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            animation: fadeIn 1s ease-out 0.6s both;
        }

        /* Module Card */
        .module-card {
            background: rgba(10, 14, 39, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 8px;
            padding: 24px;
            position: relative;
            overflow: hidden;
            transition: all 0.4s ease;
            cursor: pointer;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }

        .module-card::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.4s ease;
        }

        .module-card:hover {
            background: rgba(10, 14, 39, 0.6);
            border-color: rgba(0, 212, 255, 0.3);
            box-shadow: inset 0 0 40px rgba(0, 212, 255, 0.05),
                        0 0 40px rgba(0, 212, 255, 0.1);
            transform: translateY(-4px);
        }

        .module-card:hover::before {
            opacity: 1;
        }

        .corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid var(--primary);
            opacity: 0.5;
        }

        .corner.top-left {
            top: 0;
            left: 0;
            border-right: none;
            border-bottom: none;
        }

        .corner.top-right {
            top: 0;
            right: 0;
            border-left: none;
            border-bottom: none;
        }

        .corner.bottom-left {
            bottom: 0;
            left: 0;
            border-right: none;
            border-top: none;
        }

        .corner.bottom-right {
            bottom: 0;
            right: 0;
            border-left: none;
            border-top: none;
        }

        .module-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
            position: relative;
            z-index: 10;
        }

        .module-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
            text-transform: uppercase;
        }

        .module-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--primary);
            border-radius: 4px;
            font-size: 1rem;
            box-shadow: var(--glow-primary);
        }

        .module-badge {
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid var(--success);
            color: var(--success);
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.7rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-weight: 700;
        }

        .module-status {
            display: flex;
            gap: 8px;
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 16px;
            position: relative;
            z-index: 10;
        }

        .status-count {
            color: var(--primary);
            font-weight: 700;
        }

        .module-mini-progress {
            width: 100%;
            height: 4px;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 16px;
            position: relative;
            z-index: 10;
        }

        .module-mini-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
            box-shadow: var(--glow-primary);
        }

        .module-description {
            flex: 1;
            font-size: 0.85rem;
            color: var(--text-secondary);
            line-height: 1.4;
            position: relative;
            z-index: 10;
            margin-bottom: 16px;
        }

        .module-action {
            align-self: flex-start;
            font-size: 0.8rem;
            color: var(--primary);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            opacity: 0.7;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 10;
        }

        .module-card:hover .module-action {
            opacity: 1;
        }

        /* Detail View */
        .detail-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 30px;
            position: relative;
            z-index: 10;
        }

        .back-btn {
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            box-shadow: var(--glow-primary);
        }

        .back-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-2px);
        }

        .detail-title {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--primary);
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Detail Panel */
        .detail-panel {
            background: rgba(10, 14, 39, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 212, 255, 0.15);
            border-radius: 8px;
            padding: 30px;
            position: relative;
            margin-bottom: 30px;
        }

        .detail-panel::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.05) 0%, transparent 70%);
        }

        .detail-content {
            position: relative;
            z-index: 10;
        }

        .circular-progress-large {
            width: 140px;
            height: 140px;
            border-radius: 50%;
            background: conic-gradient(
                var(--primary) 0deg,
                var(--primary) var(--progress-angle, 0deg),
                rgba(0, 212, 255, 0.1) var(--progress-angle, 0deg)
            );
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-shadow: var(--glow-primary), inset 0 0 20px rgba(0, 212, 255, 0.1);
            margin: 0 auto 30px;
        }

        .circular-progress-large::before {
            content: '';
            position: absolute;
            width: 90%;
            height: 90%;
            background: var(--bg-dark);
            border-radius: 50%;
        }

        .progress-text-large {
            position: relative;
            z-index: 10;
            text-align: center;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
        }

        .progress-percentage-large {
            color: var(--primary);
            font-size: 2rem;
            display: block;
        }

        .progress-label-large {
            color: var(--text-secondary);
            font-size: 0.85rem;
            display: block;
            letter-spacing: 1px;
            margin-top: 4px;
        }

        .checklist {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 24px 0;
        }

        .check-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 99, 255, 0.08);
            border-left: 3px solid rgba(0, 212, 255, 0.3);
            border-radius: 2px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .check-item:hover {
            background: rgba(0, 212, 255, 0.15);
            border-left-color: var(--primary);
            box-shadow: inset 0 0 10px rgba(0, 212, 255, 0.1);
        }

        .check-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--primary);
            filter: drop-shadow(0 0 5px rgba(0, 212, 255, 0.5));
        }

        .check-item label {
            flex: 1;
            cursor: pointer;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .check-item input[type="checkbox"]:checked + label {
            color: var(--text-secondary);
            text-decoration: line-through;
        }

        .task-actions {
            display: flex;
            gap: 6px;
            margin-left: auto;
        }

        .task-btn {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.5px;
            transition: all 0.2s ease;
            text-transform: uppercase;
            font-weight: 600;
        }

        .task-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--primary);
        }

        .task-btn.delete:hover {
            background: rgba(255, 0, 110, 0.2);
            border-color: var(--accent);
            color: var(--accent);
        }

        .task-btn.edit:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: var(--success);
            color: var(--success);
        }

        .task-item-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            width: 100%;
        }

        /* Export Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-darker);
            border: 2px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 50px rgba(0, 212, 255, 0.2);
            animation: fadeIn 0.3s ease;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            padding-bottom: 15px;
        }

        .modal-title {
            font-family: 'Orbitron', monospace;
            font-size: 1.3rem;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .modal-close {
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .modal-close:hover {
            color: var(--accent);
        }

        .export-textarea {
            width: 100%;
            height: 300px;
            background: rgba(0, 99, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            margin-bottom: 15px;
            resize: none;
            overflow-y: auto;
        }

        .export-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .modal-btn {
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .modal-btn:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        /* Global keyboard focus styles */
        button:focus-visible, input:focus-visible, textarea:focus-visible, select:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        input:focus-visible, textarea:focus-visible {
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3), inset 0 0 10px rgba(0, 212, 255, 0.1);
        }

        /* Header button focus */
        header button:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .modal-btn.download {
            background: rgba(0, 255, 136, 0.15);
            border-color: var(--success);
            color: var(--success);
        }

        .modal-btn.download:hover {
            background: rgba(0, 255, 136, 0.3);
            border-color: var(--success);
        }

        /* Notes & Subtasks Modal */
        .notes-section {
            margin-bottom: 20px;
        }

        .notes-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .notes-textarea {
            width: 100%;
            height: 120px;
            background: rgba(0, 99, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            resize: none;
            margin-bottom: 15px;
        }

        .notes-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .subtasks-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
            max-height: 200px;
            overflow-y: auto;
        }

        .subtask-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 99, 255, 0.08);
            border-radius: 4px;
            border-left: 3px solid rgba(0, 212, 255, 0.3);
        }

        .subtask-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary);
        }

        .subtask-item label {
            flex: 1;
            cursor: pointer;
            color: var(--text-primary);
            font-size: 0.9rem;
        }

        .subtask-item input[type="checkbox"]:checked + label {
            color: var(--text-secondary);
            text-decoration: line-through;
        }

        .subtask-delete {
            background: transparent;
            border: none;
            color: var(--accent);
            cursor: pointer;
            font-size: 1rem;
            transition: color 0.2s ease;
        }

        .subtask-delete:hover {
            color: #ff3366;
        }

        .subtask-input-row {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .subtask-input {
            flex: 1;
            background: rgba(0, 99, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
        }

        .subtask-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }

        .subtask-add-btn {
            background: rgba(0, 255, 136, 0.15);
            border: 1px solid var(--success);
            color: var(--success);
            padding: 10px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            text-transform: uppercase;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .subtask-add-btn:hover {
            background: rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
        }

        /* Heatmap Styles */
        .heatmap-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .heatmap-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .heatmap-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: 600;
            transition: all 0.2s ease;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .heatmap-cell:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.4);
        }

        .heatmap-cell.activity-0 {
            background: rgba(0, 212, 255, 0.05);
            color: var(--text-secondary);
        }

        .heatmap-cell.activity-1 {
            background: rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
        }

        .heatmap-cell.activity-2 {
            background: rgba(0, 212, 255, 0.4);
            color: var(--bg-darker);
        }

        .heatmap-cell.activity-3 {
            background: rgba(0, 212, 255, 0.6);
            color: var(--bg-darker);
        }

        .heatmap-cell.activity-4 {
            background: var(--primary);
            color: var(--bg-darker);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.6);
        }

        .heatmap-legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 99, 255, 0.08);
            border-radius: 4px;
        }

        .heatmap-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .heatmap-legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .heatmap-day-label {
            font-size: 0.75rem;
            text-align: center;
            color: var(--text-secondary);
            text-transform: uppercase;
            font-weight: 600;
            margin-bottom: 10px;
            padding: 0 5px;
        }

        .heatmap-days-row {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            margin-bottom: 5px;
        }

        .add-task-section {
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid rgba(0, 212, 255, 0.2);
        }

        .input-field {
            width: 100%;
            background: rgba(0, 99, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 12px 16px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            background: rgba(0, 212, 255, 0.15);
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2), inset 0 0 10px rgba(0, 212, 255, 0.1);
        }

        .input-field::placeholder {
            color: rgba(0, 212, 255, 0.4);
        }

        .btn {
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-weight: 600;
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 0.85rem;
            margin-top: 12px;
            transition: all 0.3s ease;
            box-shadow: var(--glow-primary);
        }

        .btn:hover {
            background: rgba(0, 212, 255, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.4), inset 0 0 10px rgba(0, 212, 255, 0.2);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .stat-box {
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.2);
            padding: 16px;
            border-radius: 4px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .stat-box:hover {
            background: rgba(0, 212, 255, 0.15);
            border-color: var(--primary);
            box-shadow: var(--glow-primary);
        }

        .stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--primary);
            display: block;
        }

        .stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-top: 6px;
            font-weight: 600;
        }

        /* Priority and Time Estimate Styles */
        .priority-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .priority-high {
            background: var(--accent);
            box-shadow: 0 0 8px var(--accent);
        }

        .priority-medium {
            background: var(--warning);
            box-shadow: 0 0 8px var(--warning);
        }

        .priority-low {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .task-meta {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            flex-wrap: wrap;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 212, 255, 0.1);
            padding: 2px 8px;
            border-radius: 3px;
        }

        /* Inline Tag Input Styles */
        .task-tags-display {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            align-items: center;
            margin-top: 6px;
            margin-bottom: 6px;
            position: relative;
        }

        .task-tag-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            background-size: 100%;
            border: 1px solid;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            letter-spacing: 0.3px;
            position: relative;
            animation: slideIn 0.2s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: scale(0.9);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .task-tag-badge:hover .tag-remove-btn {
            opacity: 1;
        }

        .tag-remove-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 14px;
            height: 14px;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 2px;
            color: inherit;
            font-size: 0.6rem;
            padding: 0;
            opacity: 0.6;
            transition: all 0.15s ease;
            font-weight: bold;
            line-height: 1;
        }

        .tag-remove-btn:hover {
            opacity: 1;
            background: rgba(255, 255, 255, 0.4);
            transform: scale(1.15);
        }

        .task-tag-input {
            padding: 4px 8px;
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            color: var(--text-primary);
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            min-width: 100px;
            max-width: 150px;
            transition: all 0.2s ease;
            position: relative;
        }

        .task-tag-input:focus {
            outline: none;
            background: rgba(0, 212, 255, 0.15);
            border-color: var(--primary);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.2);
        }

        .task-tag-input::placeholder {
            color: var(--text-secondary);
            opacity: 0.6;
        }

        /* Autocomplete Popup */
        .tag-autocomplete-popup {
            position: absolute;
            background: var(--bg-darker);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1001;
            min-width: 150px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .tag-suggestion {
            padding: 8px 12px;
            cursor: pointer;
            font-size: 0.75rem;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
            transition: all 0.15s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-suggestion:last-child {
            border-bottom: none;
        }

        .tag-suggestion:hover,
        .tag-suggestion.selected {
            background: rgba(0, 212, 255, 0.2);
        }

        .tag-suggestion-name {
            color: var(--text-primary);
            font-weight: 500;
        }

        .tag-suggestion-count {
            color: var(--text-secondary);
            font-size: 0.65rem;
            margin-left: 8px;
        }

        .add-task-form {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .form-row.full {
            grid-template-columns: 1fr;
        }

        .select-field {
            background: rgba(0, 99, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 10px 12px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .select-field:focus {
            outline: none;
            background: rgba(0, 212, 255, 0.15);
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .select-field option {
            background: var(--bg-darker);
            color: var(--text-primary);
        }

        .filter-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 8px 14px;
            border-radius: 4px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            text-transform: uppercase;
        }

        .filter-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .filter-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--primary);
        }

        /* Global Stats Dashboard */
        .global-stats {
            margin-bottom: 40px;
        }

        .global-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 12px;
        }

        .global-stat-box {
            background: rgba(10, 14, 39, 0.4);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 212, 255, 0.15);
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .global-stat-box:hover {
            background: rgba(10, 14, 39, 0.6);
            border-color: rgba(0, 212, 255, 0.3);
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.1);
        }

        .global-stat-value {
            font-family: 'Orbitron', monospace;
            font-size: 2rem;
            font-weight: 900;
            color: var(--primary);
            display: block;
            margin-bottom: 8px;
        }

        .global-stat-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .section-divider {
            font-family: 'Orbitron', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            letter-spacing: 3px;
            margin: 60px 0 40px 0;
            padding: 20px;
            text-transform: uppercase;
            color: var(--primary);
            border-top: 1px solid rgba(0, 212, 255, 0.2);
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            text-align: center;
            position: relative;
            animation: fadeInUp 0.8s ease-out both;
        }

        .section-divider::before,
        .section-divider::after {
            content: '//';
            margin: 0 20px;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        footer {
            text-align: center;
            margin-top: 80px;
            padding: 40px 20px;
            border-top: 1px solid rgba(0, 212, 255, 0.2);
            color: var(--text-secondary);
            font-size: 0.85rem;
            letter-spacing: 1px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2rem;
                letter-spacing: 2px;
            }

            .overview-grid {
                grid-template-columns: 1fr;
                gap: 16px;
            }

            .detail-title {
                font-size: 1.5rem;
            }

            .status-line {
                flex-direction: column;
                gap: 12px;
            }
        }

        /* ============================================
           TOOLTIP SYSTEM
           ============================================ */

        .help-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            min-width: 18px;
            border-radius: 50%;
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.4);
            color: var(--primary);
            font-size: 0.75rem;
            font-weight: 700;
            cursor: help;
            margin-left: 6px;
            transition: all 0.2s ease;
            position: relative;
        }

        .help-icon:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: rgba(0, 212, 255, 0.6);
            box-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .tooltip {
            position: absolute;
            bottom: calc(100% + 12px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-darker);
            border: 1px solid var(--primary);
            border-radius: 4px;
            padding: 10px 12px;
            font-size: 0.85rem;
            color: var(--text-primary);
            white-space: nowrap;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            line-height: 1.4;
        }

        .tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-top: 6px solid var(--primary);
        }

        .help-icon:hover .tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Help modal styles */
        #helpModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        #helpModal.active {
            display: flex;
        }

        .help-modal-content {
            background: var(--bg-dark);
            border: 2px solid var(--primary);
            border-radius: 8px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            margin: auto;
            padding: 30px;
            color: var(--text-primary);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .help-modal-content h2 {
            color: var(--primary);
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--primary);
            padding-bottom: 10px;
        }

        .help-modal-content h3 {
            color: var(--secondary);
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .help-modal-content p {
            margin: 10px 0;
            line-height: 1.6;
        }

        .help-section {
            margin-bottom: 25px;
        }

        .shortcut-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        }

        .shortcut-key {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid rgba(0, 212, 255, 0.4);
            border-radius: 3px;
            padding: 4px 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            color: var(--primary);
            min-width: 100px;
            text-align: center;
        }

        .shortcut-description {
            flex: 1;
            margin-left: 15px;
            color: var(--text-secondary);
        }

        .help-modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: transparent;
            border: none;
            color: var(--primary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .help-modal-close:hover {
            color: var(--secondary);
            transform: scale(1.2);
        }

        /* First-time onboarding banner */
        .onboarding-banner {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1) 0%, rgba(0, 153, 255, 0.1) 100%);
            border: 2px solid var(--primary);
            border-radius: 6px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: none;
            align-items: center;
            gap: 15px;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .onboarding-banner.active {
            display: flex;
        }

        .onboarding-icon {
            font-size: 1.5rem;
            min-width: 24px;
            text-align: center;
        }

        .onboarding-content {
            flex: 1;
        }

        .onboarding-title {
            color: var(--primary);
            font-weight: 600;
            margin: 0 0 5px 0;
        }

        .onboarding-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin: 0;
        }

        .onboarding-close {
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.2rem;
            transition: color 0.2s ease;
        }

        .onboarding-close:hover {
            color: var(--primary);
        }

        /* Tag System Styles */
        .tag-sidebar {
            display: none !important;
            box-shadow: var(--glow-primary);
        }

        .tag-sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .tag-sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .tag-sidebar::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 3px;
        }

        .tag-sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 212, 255, 0.5);
        }

        /* Left Sidebar Tab Navigation */
        .sidebar-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            margin-bottom: 15px;
            padding-bottom: 0;
        }

        .sidebar-tab-btn {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            padding: 12px 16px;
            cursor: pointer;
            font-family: 'Space Mono', monospace;
            font-weight: 600;
            font-size: 0.75rem;
            letter-spacing: 1px;
            text-transform: uppercase;
            border-bottom: 2px solid transparent;
            transition: all 0.3s ease;
            position: relative;
        }

        .sidebar-tab-btn:hover {
            color: var(--primary);
            background: rgba(0, 212, 255, 0.05);
        }

        .sidebar-tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: rgba(0, 212, 255, 0.08);
        }

        .sidebar-panel {
            display: none;
        }

        .sidebar-panel.active {
            display: block;
        }

        .tag-suggestions {
            list-style: none;
            margin: 0;
            padding: 0;
        }

        .tag-suggestions > div {
            padding: 6px 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .tag-suggestions > div:hover {
            background: rgba(0, 212, 255, 0.15) !important;
        }

        /* Tag badge styling */
        .tag-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
        }

        /* Light theme tag styling */
        body.light-theme .tag-badge {
            background: rgba(0, 102, 204, 0.15);
            color: #0066cc;
            border: 1px solid rgba(0, 102, 204, 0.3);
        }

        /* Phase 2 Modal Styling */
        #tagManagementModal .modal-content,
        #analyticsModal .modal-content,
        #githubModal .modal-content {
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
        }

        .tag-action-btn {
            background: rgba(0, 212, 255, 0.15);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--primary);
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.75rem;
            font-weight: 600;
            transition: all 0.2s;
            font-family: 'Space Mono', monospace;
        }

        .tag-action-btn:hover {
            background: rgba(0, 212, 255, 0.25);
            border-color: rgba(0, 212, 255, 0.5);
        }

        .tag-action-btn.danger {
            background: rgba(255, 0, 110, 0.15);
            border-color: rgba(255, 0, 110, 0.3);
            color: var(--accent);
        }

        .tag-action-btn.danger:hover {
            background: rgba(255, 0, 110, 0.25);
            border-color: rgba(255, 0, 110, 0.5);
        }

        #tagManagementModal table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        #tagManagementModal th {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            color: var(--primary);
            font-weight: 600;
            font-size: 0.9rem;
        }

        #tagManagementModal td {
            padding: 12px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.1);
        }

        #tagSearchInput {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            margin-bottom: 15px;
        }

        #tagSearchInput::placeholder {
            color: var(--text-secondary);
        }

        #tagSortDropdown {
            padding: 6px 12px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            cursor: pointer;
        }

        #analyticsContent {
            padding: 15px 0;
        }

        .analytics-section {
            padding: 15px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 4px;
            margin-bottom: 15px;
        }

        #githubModal input {
            width: 100%;
            padding: 8px 12px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            color: var(--text-primary);
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            margin-bottom: 12px;
        }

        #githubTokenDisplay {
            padding: 12px;
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 4px;
            margin: 12px 0;
            font-size: 0.9rem;
        }

        /* Hide right sidebar toggle buttons */
        #showTagSidebarBtn {
            display: none !important;
        }

        /* Responsive Design for Mobile */
        @media (max-width: 768px) {
            .main-layout {
                grid-template-columns: 1fr !important;
            }

            #leftSidebar {
                position: sticky;
                top: 60px;
                max-height: calc(100vh - 120px);
            }

            .sidebar-tabs {
                display: flex;
                gap: 0;
                border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            }

            .sidebar-tab-btn {
                flex: 1;
                padding: 10px 12px;
                font-size: 0.7rem;
            }

            #modulesPanel,
            #tagsPanel {
                font-size: 0.75rem;
            }

            .module-list-item {
                padding: 8px 10px !important;
            }

            .overview-grid {
                grid-template-columns: 1fr !important;
            }

            header {
                margin-bottom: 30px;
            }

            .status-line {
                flex-wrap: wrap;
                gap: 10px;
                font-size: 0.7rem;
            }

            .section-divider {
                margin: 30px 0 20px 0;
                font-size: 1rem;
                padding: 15px;
            }
        }

        @media (max-width: 480px) {
            .sidebar-tab-btn {
                padding: 8px 10px;
                font-size: 0.65rem;
                letter-spacing: 0;
            }

            .module-list-item {
                padding: 6px 8px !important;
            }

            #leftSidebar {
                width: 100% !important;
                max-height: 200px;
            }

            .status-line {
                flex-direction: column;
                gap: 5px;
            }

            button.sidebar-tab-btn:active {
                background: rgba(0, 212, 255, 0.1);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header role="banner">
            <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle between light and dark theme" aria-pressed="false" id="themeToggle"> LIGHT</button>
            <h1> LIFE OS</h1>
            <p class="subtitle">Advanced Personal Operating System</p>
            <div class="status-line">
                <div class="status-item">
                    <span class="status-dot"></span>
                    <span>SYSTEM ONLINE</span>
                </div>
                <div class="status-item">
                    <span class="status-dot"></span>
                    <span>ALL MODULES ACTIVE</span>
                </div>
                <div class="status-item">
                    <span class="status-dot"></span>
                    <span>NEURAL SYNC OK</span>
                </div>
                <button style="margin-left: 30px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="generateWeeklyDigest()" aria-label="Generate weekly digest report with task statistics and completion metrics" aria-expanded="false" id="weeklyDigestBtn"> WEEKLY DIGEST</button>
                <button style="margin-left: 10px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="sendTaskNotifications()" id="notificationBtn" aria-label="Send browser notifications for pending and high-priority tasks" aria-pressed="false"> NOTIFY</button>
                <button style="margin-left: 10px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="openHeatmapModal()" aria-label="View 90-day activity heatmap showing task completion intensity" aria-expanded="false" id="heatmapBtn"> HEATMAP</button>
                <button style="margin-left: 10px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="openAnalyticsModal()" aria-label="View performance analytics with 30-day metrics and trends" aria-expanded="false" id="analyticsBtn"> ANALYTICS</button>
                <button style="margin-left: 10px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="openSyncModal()" aria-label="Sync center for data export, import, and GitHub integration" aria-expanded="false" id="syncBtn"> SYNC</button>
                <button style="margin-left: 10px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease;" onmouseover="this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none'" onclick="openHelpModal()" aria-label="Open help and reference guide (Cmd+?)" aria-expanded="false" id="helpBtn"> HELP</button>
                <button style="margin-left: 20px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease; opacity: 0.5;" onmouseover="if(!this.disabled) { this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)' }" onmouseout="if(!this.disabled) { this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none' }" onclick="undoAction()" aria-label="Undo last action (Cmd+Z)" id="undoBtn" disabled> UNDO</button>
                <button style="margin-left: 8px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px 14px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-size: 0.75rem; letter-spacing: 0.5px; text-transform: uppercase; font-weight: 600; transition: all 0.3s ease; opacity: 0.5;" onmouseover="if(!this.disabled) { this.style.background='rgba(0, 212, 255, 0.3)'; this.style.boxShadow='0 0 15px rgba(0, 212, 255, 0.3)' }" onmouseout="if(!this.disabled) { this.style.background='rgba(0, 212, 255, 0.15)'; this.style.boxShadow='none' }" onclick="redoAction()" aria-label="Redo last undone action (Cmd+Shift+Z)" id="redoBtn" disabled> REDO</button>
            </div>
        </header>

        <!-- Main Layout with Left Sidebar -->
        <div class="main-layout" style="display: grid; grid-template-columns: 250px 1fr; gap: 20px; align-items: start;">
            <!-- Left Sidebar -->
            <div id="leftSidebar" style="
                background: rgba(0, 0, 0, 0.2);
                border: 1px solid rgba(0, 212, 255, 0.2);
                border-radius: 8px;
                padding: 0;
                position: sticky;
                top: 100px;
                height: fit-content;
                max-height: calc(100vh - 200px);
                overflow-y: auto;
            ">
                <!-- Tab Navigation -->
                <div class="sidebar-tabs">
                    <button class="sidebar-tab-btn active" id="modulesTab" onclick="switchSidebarTab('modules')">MODULES</button>
                    <button class="sidebar-tab-btn" id="tagsTab" onclick="switchSidebarTab('tags')">TAGS</button>
                </div>

                <!-- Modules Panel -->
                <div id="modulesPanel" class="sidebar-panel active" style="padding: 15px; display: block;">
                    <div style="font-size: 0.8rem; color: var(--text-secondary); line-height: 1.6;">
                        <p style="text-align: center; margin: 20px 0; color: var(--text-secondary);">
                            Click a domain to view tasks<br>
                            <span style="font-size: 0.7rem; opacity: 0.7;">(Module details below)</span>
                        </p>
                    </div>
                    <div id="modulesList" style="display: flex; flex-direction: column; gap: 10px;">
                        <!-- Modules list will be populated by JavaScript -->
                    </div>
                </div>

                <!-- Tags Panel -->
                <div id="tagsPanel" class="sidebar-panel" style="padding: 15px; overflow-y: auto; max-height: calc(100vh - 300px);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.2); padding-bottom: 10px;">
                        <span style="color: var(--primary); font-weight: 600; font-size: 0.85rem;">MANAGE</span>
                        <button onclick="openTagManagementModal()" style="background: none; border: none; color: var(--primary); cursor: pointer; font-size: 0.9rem; opacity: 0.7; transition: opacity 0.2s;" title="Manage Tags"></button>
                    </div>
                    <div id="tagsList" style="display: flex; flex-direction: column; gap: 8px;">
                        <!-- Tags will render here -->
                    </div>
                </div>
            </div>

            <!-- Main Content Area -->
            <div style="flex: 1;">
                <!-- Dashboard Overview View -->
                <div id="overviewView" class="view-container">
                    <div class="section-divider"> Command Center</div>

                    <!-- Global Stats Dashboard -->
                    <div class="global-stats" id="globalStats" style="display: none;">
                        <div class="section-divider" style="margin: 40px 0 20px 0; font-size: 1rem;"> Global Statistics</div>
                        <div class="global-stats-grid" id="globalStatsGrid">
                            <!-- Stats will be populated by JavaScript -->
                        </div>
                    </div>

                    <div class="overview-grid" id="moduleGrid">
                        <!-- Modules will be populated by JavaScript -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Detail View -->
        <div id="detailView" class="view-container hidden-view">
            <div class="detail-header">
                <button class="back-btn" onclick="backToDashboard()"> BACK</button>
                <div class="detail-title">
                    <span id="detailIcon"></span>
                    <span id="detailName"></span>
                </div>
            </div>

            <div class="detail-panel">
                <div class="detail-content">
                    <div class="circular-progress-large" id="detailCircle" style="--progress-angle: 0deg;">
                        <div class="progress-text-large">
                            <span class="progress-percentage-large" id="detailPercent">0</span>%<br>
                            <span class="progress-label-large">COMPLETE</span>
                        </div>
                    </div>

                    <div class="stats-grid">
                        <div class="stat-box">
                            <span class="stat-value" id="detailComplete">0</span>
                            <span class="stat-label">COMPLETED</span>
                        </div>
                        <div class="stat-box">
                            <span class="stat-value" id="detailTotal">0</span>
                            <span class="stat-label">TOTAL</span>
                        </div>
                    </div>

                    <!-- Filter Buttons -->
                    <div class="filter-buttons" id="filterButtons">
                        <button class="filter-btn active" onclick="setFilter('all')">ALL TASKS</button>
                        <button class="filter-btn" onclick="setFilter('today')">TODAY</button>
                        <button class="filter-btn" onclick="setFilter('week')">THIS WEEK</button>
                        <button class="filter-btn" onclick="setFilter('high')">HIGH PRIORITY</button>
                        <button class="filter-btn" onclick="exportModuleMarkdown()"> EXPORT MD</button>
                    </div>

                    <div id="detailChecklist" class="checklist"></div>

                    <div class="add-task-section">
                        <div class="add-task-form">
                            <input type="text" id="detailInput" class="input-field" placeholder="// task description...">
                            <div class="form-row">
                                <select id="prioritySelect" class="select-field">
                                    <option value="medium">PRIORITY: MEDIUM</option>
                                    <option value="high">PRIORITY: HIGH</option>
                                    <option value="low">PRIORITY: LOW</option>
                                </select>
                                <select id="recurrenceSelect" class="select-field">
                                    <option value="none">RECURRING: NONE</option>
                                    <option value="daily">RECURRING: DAILY</option>
                                    <option value="weekly">RECURRING: WEEKLY</option>
                                    <option value="monthly">RECURRING: MONTHLY</option>
                                </select>
                            </div>
                            <div class="form-row">
                                <input type="number" id="estimateInput" class="input-field" placeholder="TIME ESTIMATE (hours)" min="0" max="1000" step="0.5" value="1">
                            </div>
                            <button class="btn" onclick="addDetailTask()">EXECUTE TASK</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Export Modal -->
        <div id="exportModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="exportModalTitle" onclick="if(event.target === this) closeExportModal()">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="exportModalTitle"> EXPORT MARKDOWN</div>
                    <button class="modal-close" onclick="closeExportModal()" aria-label="Close export dialog"></button>
                </div>
                <textarea id="exportTextarea" class="export-textarea" readonly></textarea>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="copyExportToClipboard()"> COPY</button>
                    <button class="modal-btn download" onclick="downloadExportFile()"> DOWNLOAD</button>
                </div>
            </div>
        </div>

        <!-- Heatmap Modal -->
        <div id="heatmapModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="heatmapModalTitle" onclick="if(event.target === this) closeHeatmapModal()">
            <div class="modal-content" style="max-width: 900px;">
                <div class="modal-header">
                    <div class="modal-title" id="heatmapModalTitle"> ACTIVITY HEATMAP</div>
                    <button class="modal-close" onclick="closeHeatmapModal()" aria-label="Close heatmap dialog"></button>
                </div>
                <div class="heatmap-container">
                    <div id="heatmapContent" style="overflow-y: auto; max-height: 500px;"></div>
                    <div class="heatmap-legend">
                        <div class="heatmap-legend-item">
                            <div class="heatmap-legend-color" style="background: rgba(0, 212, 255, 0.05);"></div>
                            <span>No Activity</span>
                        </div>
                        <div class="heatmap-legend-item">
                            <div class="heatmap-legend-color" style="background: rgba(0, 212, 255, 0.2);"></div>
                            <span>Low (1-25%)</span>
                        </div>
                        <div class="heatmap-legend-item">
                            <div class="heatmap-legend-color" style="background: rgba(0, 212, 255, 0.4);"></div>
                            <span>Medium (26-50%)</span>
                        </div>
                        <div class="heatmap-legend-item">
                            <div class="heatmap-legend-color" style="background: rgba(0, 212, 255, 0.6);"></div>
                            <span>High (51-75%)</span>
                        </div>
                        <div class="heatmap-legend-item">
                            <div class="heatmap-legend-color" style="background: var(--primary); box-shadow: 0 0 10px rgba(0, 212, 255, 0.6);"></div>
                            <span>Very High (76-100%)</span>
                        </div>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeHeatmapModal()">CLOSE</button>
                </div>
            </div>
        </div>

        <!-- Weekly Digest Modal -->
        <div id="digestModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="digestModalTitle" onclick="if(event.target === this) closeDigestModal()">
            <div class="modal-content" style="max-width: 800px; max-height: 85vh;">
                <div class="modal-header">
                    <div class="modal-title" id="digestModalTitle"> WEEKLY DIGEST REPORT</div>
                    <button class="modal-close" onclick="closeDigestModal()" aria-label="Close digest dialog"></button>
                </div>
                <div id="digestContent" style="overflow-y: auto; height: 500px; padding: 20px; background: rgba(0, 99, 255, 0.08); border-radius: 4px; margin-bottom: 20px; font-size: 0.9rem; line-height: 1.6;"></div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeDigestModal()">CLOSE</button>
                    <button class="modal-btn" onclick="copyDigestToClipboard()"> COPY</button>
                    <button class="modal-btn download" onclick="downloadDigestReport()"> DOWNLOAD</button>
                </div>
            </div>
        </div>

        <!-- Notes & Subtasks Modal -->
        <div id="notesModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="notesModalTitle" onclick="if(event.target === this) closeNotesModal()">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <div class="modal-title" id="notesModalTitle"> TASK DETAILS</div>
                    <button class="modal-close" onclick="closeNotesModal()" aria-label="Close task details dialog"></button>
                </div>

                <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                    <div style="color: var(--primary); font-size: 1.1rem; font-weight: 700;" id="notesTaskTitle"></div>
                </div>

                <!-- Tag Section -->
                <div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid rgba(0, 212, 255, 0.2);">
                    <label class="notes-label"> Tags</label>
                    <div style="margin-bottom: 10px;">
                        <div id="currentTagsList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 10px;">
                            <!-- Tags will be rendered here -->
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="tagInput" class="input-field" placeholder="Add tag..." autocomplete="off" style="flex: 1; font-size: 0.9rem;">
                        <button id="addTagBtn" class="btn" onclick="addTagFromModal()" style="width: auto; padding: 8px 16px;">+ ADD TAG</button>
                    </div>
                    <div id="tagSuggestions" class="tag-suggestions" style="display: none; margin-top: 8px; background: rgba(0, 99, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px; padding: 8px; max-height: 150px; overflow-y: auto;">
                        <!-- Auto-suggestions will appear here -->
                    </div>
                </div>

                <div class="notes-section">
                    <label class="notes-label"> Notes</label>
                    <textarea id="notesText" class="notes-textarea" placeholder="Add detailed notes about this task..."></textarea>
                </div>

                <div class="notes-section">
                    <label class="notes-label"> Subtasks</label>
                    <div class="subtask-input-row">
                        <input type="text" id="subtaskInput" class="subtask-input" placeholder="Add a subtask..." />
                        <button class="subtask-add-btn" onclick="addSubtask()">+ ADD</button>
                    </div>
                    <div id="subtasksList" class="subtasks-list"></div>
                </div>

                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeNotesModal()">CLOSE</button>
                    <button class="modal-btn download" onclick="saveTaskDetails()"> SAVE</button>
                </div>
            </div>
        </div>

        <!-- Analytics Modal -->
        <div id="analyticsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="analyticsModalTitle" onclick="if(event.target === this) closeAnalyticsModal()">
            <div class="modal-content" style="max-width: 1000px; max-height: 85vh;">
                <div class="modal-header">
                    <div class="modal-title" id="analyticsModalTitle"> PERFORMANCE ANALYTICS</div>
                    <button class="modal-close" onclick="closeAnalyticsModal()" aria-label="Close analytics dialog"></button>
                </div>
                <div id="analyticsContent" style="overflow-y: auto; height: 550px; padding: 20px; background: rgba(0, 99, 255, 0.08); border-radius: 4px; margin-bottom: 20px; font-size: 0.85rem; line-height: 1.6;"></div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeAnalyticsModal()">CLOSE</button>
                    <button class="modal-btn" onclick="copyAnalyticsToClipboard()"> COPY</button>
                    <button class="modal-btn download" onclick="downloadAnalyticsReport()"> DOWNLOAD</button>
                </div>
            </div>
        </div>

        <!-- Sync Modal -->
        <div id="syncModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="syncModalTitle" onclick="if(event.target === this) closeSyncModal()">
            <div class="modal-content" style="max-width: 900px;">
                <div class="modal-header">
                    <div class="modal-title" id="syncModalTitle"> SYNC & INTEGRATION CENTER</div>
                    <button class="modal-close" onclick="closeSyncModal()" aria-label="Close sync center dialog"></button>
                </div>

                <!-- Sync Tabs -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid rgba(0, 212, 255, 0.2); padding-bottom: 15px;">
                    <button onclick="showSyncTab('export')" id="tab-export" class="sync-tab-btn active" style="background: rgba(0, 212, 255, 0.2); color: var(--primary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-weight: 600; font-size: 0.8rem;"> EXPORT</button>
                    <button onclick="showSyncTab('import')" id="tab-import" class="sync-tab-btn" style="background: transparent; color: var(--text-secondary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-weight: 600; font-size: 0.8rem;"> IMPORT</button>
                    <button onclick="showSyncTab('github')" id="tab-github" class="sync-tab-btn" style="background: transparent; color: var(--text-secondary); border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; font-weight: 600; font-size: 0.8rem;"> GITHUB</button>
                </div>

                <!-- Export Tab -->
                <div id="syncTab-export" class="sync-tab-content">
                    <h4 style="color: var(--primary); margin-bottom: 15px;"> EXPORT YOUR DATA</h4>
                    <p style="margin-bottom: 15px; color: var(--text-secondary);">Download all your tasks and settings as a JSON file for backup or migration.</p>
                    <div style="background: rgba(0, 99, 255, 0.08); padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                        <p style="font-size: 0.85rem; margin-bottom: 10px;"><strong> Available Data:</strong></p>
                        <ul style="list-style: none; padding: 0; font-size: 0.8rem; line-height: 1.8;">
                            <li> All 9 modules (tasks, priorities, estimates)</li>
                            <li> Notes and subtasks</li>
                            <li> Recurring task configuration</li>
                            <li> Creation dates and timestamps</li>
                            <li> Theme preference</li>
                        </ul>
                    </div>
                    <div class="modal-buttons">
                        <button class="modal-btn download" onclick="exportDataAsJSON()"> DOWNLOAD BACKUP</button>
                        <button class="modal-btn" onclick="copyDataToClipboard()"> COPY JSON</button>
                    </div>
                </div>

                <!-- Import Tab -->
                <div id="syncTab-import" class="sync-tab-content" style="display: none;">
                    <h4 style="color: var(--primary); margin-bottom: 15px;"> IMPORT YOUR DATA</h4>
                    <p style="margin-bottom: 15px; color: var(--text-secondary);">Restore tasks from a previously exported JSON file.</p>
                    <div style="background: rgba(255, 170, 0, 0.1); padding: 15px; border-radius: 4px; margin-bottom: 15px; border: 1px solid rgba(255, 170, 0, 0.3);">
                        <p style="font-size: 0.8rem; color: var(--warning);"><strong> WARNING:</strong> Importing will merge with existing data. Back up first!</p>
                    </div>
                    <div style="margin-bottom: 15px;">
                        <label for="importJSON" style="display: block; margin-bottom: 10px; font-weight: 600; color: var(--primary);">Paste your JSON data:</label>
                        <textarea id="importJSON" aria-label="Paste exported JSON data" aria-describedby="importJSONHelper" style="width: 100%; height: 200px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 10px; border-radius: 4px; font-family: 'Space Mono', monospace; font-size: 0.75rem; resize: vertical;"></textarea>
                        <small id="importJSONHelper" style="display: block; margin-top: 5px; color: var(--text-secondary); font-size: 0.75rem;">Paste complete JSON from exported backup file</small>
                    </div>
                    <div class="modal-buttons">
                        <button class="modal-btn" onclick="importDataFromJSON()"> IMPORT DATA</button>
                        <button class="modal-btn" onclick="clearImportField()"> CLEAR</button>
                    </div>
                </div>

                <!-- GitHub Tab -->
                <div id="syncTab-github" class="sync-tab-content" style="display: none;">
                    <h4 style="color: var(--primary); margin-bottom: 15px;"> GITHUB ISSUES INTEGRATION</h4>
                    <p style="margin-bottom: 15px; color: var(--text-secondary);">Export your tasks as GitHub Issues for collaborative tracking.</p>

                    <div style="background: rgba(0, 99, 255, 0.08); padding: 15px; border-radius: 4px; margin-bottom: 15px;">
                        <p style="font-size: 0.85rem; margin-bottom: 10px;"><strong> How it works:</strong></p>
                        <ol style="font-size: 0.8rem; line-height: 1.8; padding-left: 20px;">
                            <li>Copy your GitHub Personal Access Token (ghp_*)</li>
                            <li>Enter repo in format: username/repository</li>
                            <li>Select which tasks to export</li>
                            <li>Issues created with priority labels and estimates</li>
                        </ol>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label for="githubToken" style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--primary);">GitHub Token:</label>
                        <input type="password" id="githubToken" placeholder="ghp_XXXXXXXXXXXX" aria-label="GitHub Personal Access Token" aria-describedby="tokenHelper" style="width: 100%; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px; border-radius: 4px; font-family: 'Space Mono', monospace;" />
                        <small id="tokenHelper" style="display: block; margin-top: 4px; color: var(--text-secondary); font-size: 0.75rem;">Create token at github.com/settings/tokens with repo permissions</small>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label for="githubRepo" style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--primary);">Repository:</label>
                        <input type="text" id="githubRepo" placeholder="username/repository" aria-label="GitHub repository in format username/repository" aria-describedby="repoHelper" style="width: 100%; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-primary); padding: 8px; border-radius: 4px; font-family: 'Space Mono', monospace;" />
                        <small id="repoHelper" style="display: block; margin-top: 4px; color: var(--text-secondary); font-size: 0.75rem;">Format: username/repository-name</small>
                    </div>

                    <div style="margin-bottom: 15px;">
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: var(--primary);">Export Options:</label>
                        <div style="display: flex; gap: 15px;">
                            <label style="display: flex; align-items: center; gap: 8px; font-size: 0.85rem;">
                                <input type="checkbox" id="gh-only-pending" checked /> Only pending tasks
                            </label>
                            <label style="display: flex; align-items: center; gap: 8px; font-size: 0.85rem;">
                                <input type="checkbox" id="gh-high-priority" /> High priority only
                            </label>
                        </div>
                    </div>

                    <div class="modal-buttons">
                        <button class="modal-btn download" onclick="exportToGitHubIssues()"> EXPORT TO GITHUB</button>
                        <button class="modal-btn" onclick="validateGitHubCredentials()"> TEST CONNECTION</button>
                    </div>
                </div>

                <div class="modal-buttons" style="margin-top: 20px; border-top: 1px solid rgba(0, 212, 255, 0.2); padding-top: 15px;">
                    <button class="modal-btn" onclick="closeSyncModal()">CLOSE</button>
                </div>
            </div>
        </div>

        <!-- Help Modal -->
        <div id="helpModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle" onclick="if(event.target === this) closeHelpModal()">
            <div class="modal-content" style="max-width: 900px; max-height: 85vh;">
                <div class="modal-header">
                    <div class="modal-title" id="helpModalTitle"> HELP & REFERENCE</div>
                    <button class="modal-close" onclick="closeHelpModal()" aria-label="Close help dialog"></button>
                </div>

                <div class="help-tabs" style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid rgba(0, 212, 255, 0.2); padding-bottom: 15px; overflow-x: auto;">
                    <button onclick="showHelpTab('quickstart')" id="help-tab-quickstart" class="help-tab-btn active"> QUICK START</button>
                    <button onclick="showHelpTab('features')" id="help-tab-features" class="help-tab-btn"> FEATURES</button>
                    <button onclick="showHelpTab('shortcuts')" id="help-tab-shortcuts" class="help-tab-btn"> SHORTCUTS</button>
                    <button onclick="showHelpTab('urlparams')" id="help-tab-urlparams" class="help-tab-btn"> URL PARAMS</button>
                    <button onclick="showHelpTab('tips')" id="help-tab-tips" class="help-tab-btn"> TIPS</button>
                    <button onclick="showHelpTab('faq')" id="help-tab-faq" class="help-tab-btn"> FAQ</button>
                </div>

                <div id="helpContent" style="overflow-y: auto; height: 500px; padding: 20px; background: rgba(0, 99, 255, 0.08); border-radius: 4px; margin-bottom: 20px;">
                    <!-- Quick Start Tab -->
                    <div id="help-quickstart" class="help-tab-content">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> Getting Started</h3>
                        <ol style="line-height: 2; color: var(--text-primary); font-size: 0.95rem;">
                            <li><strong>View Dashboard:</strong> See all 9 life domains at a glance with progress indicators</li>
                            <li><strong>Click a Module:</strong> Enter detail view to see and manage tasks</li>
                            <li><strong>Add a Task:</strong> Enter task description, select priority (High/Medium/Low), set time estimate in hours</li>
                            <li><strong>Complete Tasks:</strong> Click checkboxes to mark tasks complete and track progress</li>
                            <li><strong>Use Filters:</strong> View All tasks, Today's tasks, This Week, or High Priority only</li>
                            <li><strong>Track Progress:</strong> Watch the circular progress bar update as you complete tasks</li>
                        </ol>
                    </div>

                    <!-- Features Tab -->
                    <div id="help-features" class="help-tab-content" style="display: none;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> Features Overview</h3>
                        <div style="display: grid; gap: 15px;">
                            <div style="border-left: 3px solid var(--primary); padding-left: 15px;">
                                <strong style="color: var(--primary);"> Global Statistics</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">View overall completion rate, total hours, and high-priority task progress across all modules</p>
                            </div>
                            <div style="border-left: 3px solid var(--success); padding-left: 15px;">
                                <strong style="color: var(--success);"> Smart Filtering</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Filter by All, Today, This Week, or High Priority to focus on what matters most</p>
                            </div>
                            <div style="border-left: 3px solid var(--warning); padding-left: 15px;">
                                <strong style="color: var(--warning);"> Notes & Subtasks</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Add detailed notes and break tasks into subtasks for better organization</p>
                            </div>
                            <div style="border-left: 3px solid var(--accent); padding-left: 15px;">
                                <strong style="color: var(--accent);"> Recurring Tasks</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Set tasks to repeat daily, weekly, or monthly automatically</p>
                            </div>
                            <div style="border-left: 3px solid #00ff88; padding-left: 15px;">
                                <strong style="color: #00ff88;"> Undo/Redo</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Revert or replay actions with keyboard shortcuts or header buttons</p>
                            </div>
                            <div style="border-left: 3px solid #0099ff; padding-left: 15px;">
                                <strong style="color: #0099ff;"> Export & Import</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Backup your data or restore from exports through the Sync Center</p>
                            </div>
                            <div style="border-left: 3px solid #ff006e; padding-left: 15px;">
                                <strong style="color: #ff006e;"> Dark/Light Theme</strong>
                                <p style="color: var(--text-secondary); margin-top: 5px; font-size: 0.9rem;">Toggle between dark and light themes to suit your preference</p>
                            </div>
                        </div>
                    </div>

                    <!-- Keyboard Shortcuts Tab -->
                    <div id="help-shortcuts" class="help-tab-content" style="display: none;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> Keyboard Shortcuts</h3>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 0.9rem;">
                            <div style="border: 1px solid rgba(0, 212, 255, 0.2); padding: 12px; border-radius: 4px;">
                                <div style="color: var(--primary); font-weight: 600; margin-bottom: 8px;"> Undo</div>
                                <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Cmd+Z</code> or <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Ctrl+Z</code>
                            </div>
                            <div style="border: 1px solid rgba(0, 212, 255, 0.2); padding: 12px; border-radius: 4px;">
                                <div style="color: var(--primary); font-weight: 600; margin-bottom: 8px;"> Redo</div>
                                <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Cmd+Shift+Z</code> or <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Ctrl+Shift+Z</code>
                            </div>
                            <div style="border: 1px solid rgba(0, 212, 255, 0.2); padding: 12px; border-radius: 4px;">
                                <div style="color: var(--primary); font-weight: 600; margin-bottom: 8px;"> Redo (Alt)</div>
                                <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Cmd+Y</code> or <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Ctrl+Y</code>
                            </div>
                            <div style="border: 1px solid rgba(0, 212, 255, 0.2); padding: 12px; border-radius: 4px;">
                                <div style="color: var(--primary); font-weight: 600; margin-bottom: 8px;"> Help</div>
                                <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Cmd+?</code> or <code style="background: rgba(0, 0, 0, 0.3); padding: 4px 8px; border-radius: 3px; color: var(--text-primary);">Ctrl+?</code>
                            </div>
                        </div>
                        <p style="color: var(--text-secondary); margin-top: 15px; font-size: 0.85rem;">More shortcuts coming in next update!</p>
                    </div>

                    <!-- URL Parameters Tab -->
                    <div id="help-urlparams" class="help-tab-content" style="display: none;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> URL Parameters (Bookmarking)</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9rem;">You can customize your view by adding parameters to the URL:</p>
                        <div style="display: grid; gap: 12px; font-size: 0.85rem;">
                            <div style="background: rgba(0, 99, 255, 0.1); padding: 12px; border-radius: 4px; border-left: 3px solid var(--primary);">
                                <strong style="color: var(--primary);">?module=afr</strong>
                                <p style="color: var(--text-secondary); margin-top: 4px;">Load specific module (afr, uxr, home, family, teaching, service, bellon, oak, health)</p>
                            </div>
                            <div style="background: rgba(0, 99, 255, 0.1); padding: 12px; border-radius: 4px; border-left: 3px solid var(--secondary);">
                                <strong style="color: var(--secondary);">?filter=today</strong>
                                <p style="color: var(--text-secondary); margin-top: 4px;">Set filter (all, today, week, priority)</p>
                            </div>
                            <div style="background: rgba(0, 99, 255, 0.1); padding: 12px; border-radius: 4px; border-left: 3px solid var(--accent);">
                                <strong style="color: var(--accent);">?theme=light</strong>
                                <p style="color: var(--text-secondary); margin-top: 4px;">Set theme (dark or light)</p>
                            </div>
                        </div>
                        <p style="color: var(--text-secondary); margin-top: 15px; font-size: 0.85rem; background: rgba(255, 170, 0, 0.1); padding: 12px; border-radius: 4px; border-left: 3px solid var(--warning);"> <strong>Pro Tip:</strong> Bookmark URLs to quickly jump to your favorite views!</p>
                    </div>

                    <!-- Tips Tab -->
                    <div id="help-tips" class="help-tab-content" style="display: none;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> Pro Tips</h3>
                        <ol style="line-height: 2.2; color: var(--text-primary); font-size: 0.9rem;">
                            <li><strong>Priority Matters:</strong> Use High priority strategically for truly important tasks only</li>
                            <li><strong>Time Estimates:</strong> Be realistic with hoursthis helps you assess workload capacity</li>
                            <li><strong>Daily Review:</strong> Check the "Today" filter each morning to stay focused</li>
                            <li><strong>Recurring Tasks:</strong> Set up weekly or monthly recurring tasks for routine work</li>
                            <li><strong>Notes for Context:</strong> Add details in task notes to remember why it matters</li>
                            <li><strong>Subtasks for Complexity:</strong> Break large tasks into subtasks for better progress tracking</li>
                            <li><strong>Undo Liberally:</strong> Don't fear mistakesundo/redo is always available</li>
                            <li><strong>Backup Regularly:</strong> Export your data monthly for safety</li>
                            <li><strong>Bookmark Workflows:</strong> Save URLs for your common work patterns (e.g., ?module=home&filter=today)</li>
                            <li><strong>Dark Theme:</strong> Use light theme during day, dark theme for evening work</li>
                        </ol>
                    </div>

                    <!-- FAQ Tab -->
                    <div id="help-faq" class="help-tab-content" style="display: none;">
                        <h3 style="color: var(--primary); margin-bottom: 15px;"> Frequently Asked Questions</h3>
                        <div style="display: grid; gap: 15px;">
                            <div>
                                <strong style="color: var(--primary);">Where is my data stored?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">All data is stored locally in your browser's localStorage. It never leaves your device unless you export it.</p>
                            </div>
                            <div>
                                <strong style="color: var(--primary);">Can I use this offline?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">Yes! Once loaded, Life OS works completely offline. Create, edit, and manage tasks without internet.</p>
                            </div>
                            <div>
                                <strong style="color: var(--primary);">How do I backup my data?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">Click the  icon to open Sync Center, then use the Export tab to download your data as JSON.</p>
                            </div>
                            <div>
                                <strong style="color: var(--primary);">Can I sync across devices?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">Currently you can export/import manually. Cloud sync is planned for a future release.</p>
                            </div>
                            <div>
                                <strong style="color: var(--primary);">What happens if I clear browser cache?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">Your data will be lost. Always export first if clearing cache. Consider enabling browser data protection.</p>
                            </div>
                            <div>
                                <strong style="color: var(--primary);">Can I edit the modules/domains?</strong>
                                <p style="color: var(--text-secondary); margin-top: 8px; font-size: 0.9rem;">Currently the 9 domains are fixed, but you can customize the application by editing index.html directly.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeHelpModal()">CLOSE</button>
                </div>
            </div>
        </div>

        <!-- First-Time User Onboarding Banner -->
        <div id="onboardingBanner" class="onboarding-banner" style="display: none;">
            <div class="onboarding-content">
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 2rem;"></div>
                    <div>
                        <div style="font-weight: 700; color: var(--primary); font-size: 1.05rem; margin-bottom: 4px;">Welcome to Life OS!</div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">Your command center for managing all life domains. Need help? Click the  icon or press Cmd+?</div>
                    </div>
                </div>
                <button class="onboarding-close" onclick="dismissOnboardingBanner()" aria-label="Dismiss onboarding banner" style="background: transparent; border: none; color: var(--text-secondary); cursor: pointer; font-size: 1.3rem; padding: 0; opacity: 0.7; transition: opacity 0.2s;"></button>
            </div>
        </div>

        <!-- Tag Sidebar -->
        <div id="tagSidebar" class="tag-sidebar" style="
            position: fixed;
            right: 0;
            bottom: 0;
            width: 250px;
            height: 400px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 212, 255, 0.2);
            border-radius: 8px 8px 0 0;
            padding: 15px;
            overflow-y: auto;
            font-size: 0.85rem;
            z-index: 100;
            display: none;
            flex-direction: column;
            gap: 10px;
            box-shadow: var(--glow-primary);
        ">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; border-bottom: 1px solid rgba(0, 212, 255, 0.2); padding-bottom: 10px;">
                <span style="color: var(--primary); font-weight: 600;"> TAGS</span>
                <div style="display: flex; gap: 5px;">
                    <button onclick="openTagManagementModal()" style="background: none; border: none; color: var(--primary); cursor: pointer; font-size: 1rem;" title="Manage Tags"></button>
                    <button onclick="toggleTagSidebar()" style="background: none; border: none; color: var(--primary); cursor: pointer;"></button>
                </div>
            </div>
            <div id="tagsList" style="flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                <!-- Tags will render here -->
            </div>
            <button id="toggleTagSidebarBtn" class="btn" onclick="toggleTagSidebar()" style="width: 100%; margin-top: auto; padding: 8px;">HIDE TAGS</button>
        </div>

        <!-- Toggle Tag Sidebar Button -->
        <button id="showTagSidebarBtn" class="btn" onclick="toggleTagSidebar()" style="position: fixed; right: 20px; bottom: 20px; z-index: 99; display: none;"> TAGS</button>

        <!-- Tag Management Modal (Phase 2a) -->
        <div id="tagManagementModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="tagMgmtTitle" onclick="if(event.target === this) closeTagManagementModal()">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="tagMgmtTitle"> TAG MANAGEMENT</div>
                    <button class="modal-close" onclick="closeTagManagementModal()" aria-label="Close tag management dialog"></button>
                </div>
                <div style="padding: 20px;">
                    <input type="text" id="tagSearchInput" placeholder=" Search tags...">
                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <label style="color: var(--text-secondary); font-size: 0.9rem;">Sort by:</label>
                        <select id="tagSortDropdown">
                            <option value="usage">Usage (Most)</option>
                            <option value="name">Name (A-Z)</option>
                            <option value="created">Created (Newest)</option>
                            <option value="lastused">Last Used</option>
                        </select>
                    </div>
                    <table>
                        <thead>
                            <tr>
                                <th>Tag Name</th>
                                <th style="width: 80px; text-align: center;">Usage</th>
                                <th style="width: 120px;">Created</th>
                                <th style="width: 80px; text-align: center;">Status</th>
                                <th style="width: 200px; text-align: right;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="tagTableBody">
                            <!-- Tags will render here -->
                        </tbody>
                    </table>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeTagManagementModal()">DONE</button>
                </div>
            </div>
        </div>

        <!-- Analytics Dashboard Modal (Phase 2d) -->
        <div id="analyticsModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="analyticsTitle" onclick="if(event.target === this) closeAnalyticsDashboard()">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="analyticsTitle"> TAG ANALYTICS</div>
                    <button class="modal-close" onclick="closeAnalyticsDashboard()" aria-label="Close analytics dialog"></button>
                </div>
                <div style="padding: 20px;">
                    <div id="analyticsContent">
                        <!-- Analytics will render here -->
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeAnalyticsDashboard()">CLOSE</button>
                </div>
            </div>
        </div>

        <!-- GitHub Integration Modal (Phase 2e) -->
        <div id="githubModal" class="modal" role="dialog" aria-modal="true" aria-labelledby="githubTitle" onclick="if(event.target === this) closeGitHubSettings()">
            <div class="modal-content">
                <div class="modal-header">
                    <div class="modal-title" id="githubTitle"> GITHUB INTEGRATION</div>
                    <button class="modal-close" onclick="closeGitHubSettings()" aria-label="Close GitHub settings"></button>
                </div>
                <div style="padding: 20px;">
                    <div style="margin-bottom: 20px;">
                        <h3 style="color: var(--primary); margin-top: 0;">Connection Status</h3>
                        <div id="githubTokenDisplay">Not connected to GitHub</div>
                        <div style="display: flex; gap: 10px; margin-top: 12px;">
                            <button id="githubConnectBtn" class="modal-btn" onclick="connectToGitHub()" style="display: none;"> CONNECT</button>
                            <button id="githubDisconnectBtn" class="modal-btn" onclick="disconnectFromGitHub()" style="display: none;"> DISCONNECT</button>
                        </div>
                    </div>

                    <div style="border-top: 1px solid rgba(0, 212, 255, 0.2); padding-top: 20px;">
                        <h3 style="color: var(--primary);">Export & Sync</h3>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            <button class="modal-btn" onclick="exportTagsToGitHub()" style="width: 100%;"> EXPORT TAGS AS LABELS</button>
                            <button class="modal-btn" onclick="importLabelsFromGitHub()" style="width: 100%;"> IMPORT LABELS AS TAGS</button>
                        </div>
                    </div>

                    <div style="border-top: 1px solid rgba(0, 212, 255, 0.2); margin-top: 20px; padding-top: 20px; font-size: 0.85rem; color: var(--text-secondary);">
                        <p> Note: You'll need a GitHub personal access token with 'repo' scope.</p>
                        <p>Get one at: <a href="https://github.com/settings/tokens" target="_blank" style="color: var(--primary);">github.com/settings/tokens</a></p>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button class="modal-btn" onclick="closeGitHubSettings()">CLOSE</button>
                </div>
            </div>
        </div>

        <!-- Color Picker Modal (Phase 3b) -->
        <div id="colorPickerModal" class="modal" style="z-index: 2000;">
            <div class="modal-content" style="max-width: 400px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">Color Picker</h3>
                    <button onclick="document.getElementById('colorPickerModal').classList.remove('active')" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-secondary);"></button>
                </div>

                <!-- Hue Slider -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: var(--text-secondary);">HUE: <span id="hueValue">200</span></label>
                    <input id="hueSlider" type="range" min="0" max="360" value="200" style="width: 100%; cursor: pointer;" oninput="updateColorPreview()">
                </div>

                <!-- Saturation Slider -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: var(--text-secondary);">SATURATION: <span id="saturationValue">85%</span></label>
                    <input id="saturationSlider" type="range" min="0" max="100" value="85" style="width: 100%; cursor: pointer;" oninput="updateColorPreview()">
                </div>

                <!-- Lightness Slider -->
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; font-size: 0.9rem; color: var(--text-secondary);">LIGHTNESS: <span id="lightnessValue">45%</span></label>
                    <input id="lightnessSlider" type="range" min="0" max="100" value="45" style="width: 100%; cursor: pointer;" oninput="updateColorPreview()">
                </div>

                <!-- Color Preview -->
                <div style="margin-bottom: 15px;">
                    <div id="colorPreview" style="width: 100%; height: 60px; border-radius: 4px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-family: monospace; margin-bottom: 8px;">#00FFAA</div>
                    <div id="contrastRatio" style="text-align: center; font-size: 0.85rem; color: var(--success);">Contrast: 5.2:1 </div>
                </div>

                <!-- Preset Palettes -->
                <div style="margin-bottom: 15px;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">PRESETS:</div>

                    <!-- Vibrant Palette -->
                    <div style="margin-bottom: 8px;">
                        <button onclick="applyColorPreset('vibrant', 0)" style="width: 20px; height: 20px; background: hsl(0, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 1)" style="width: 20px; height: 20px; background: hsl(30, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 2)" style="width: 20px; height: 20px; background: hsl(60, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 3)" style="width: 20px; height: 20px; background: hsl(120, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 4)" style="width: 20px; height: 20px; background: hsl(180, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 5)" style="width: 20px; height: 20px; background: hsl(240, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 6)" style="width: 20px; height: 20px; background: hsl(270, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('vibrant', 7)" style="width: 20px; height: 20px; background: hsl(330, 100%, 50%); border: 1px solid rgba(255,255,255,0.3); cursor: pointer;"></button>
                    </div>

                    <!-- Pastel Palette -->
                    <div style="margin-bottom: 8px;">
                        <button onclick="applyColorPreset('pastel', 0)" style="width: 20px; height: 20px; background: hsl(0, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 1)" style="width: 20px; height: 20px; background: hsl(30, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 2)" style="width: 20px; height: 20px; background: hsl(60, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 3)" style="width: 20px; height: 20px; background: hsl(120, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 4)" style="width: 20px; height: 20px; background: hsl(180, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 5)" style="width: 20px; height: 20px; background: hsl(240, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 6)" style="width: 20px; height: 20px; background: hsl(270, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('pastel', 7)" style="width: 20px; height: 20px; background: hsl(330, 70%, 75%); border: 1px solid rgba(255,255,255,0.3); cursor: pointer;"></button>
                    </div>

                    <!-- Grayscale Palette -->
                    <div>
                        <button onclick="applyColorPreset('grayscale', 0)" style="width: 20px; height: 20px; background: hsl(0, 0%, 100%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('grayscale', 1)" style="width: 20px; height: 20px; background: hsl(0, 0%, 75%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('grayscale', 2)" style="width: 20px; height: 20px; background: hsl(0, 0%, 50%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('grayscale', 3)" style="width: 20px; height: 20px; background: hsl(0, 0%, 25%); border: 1px solid rgba(255,255,255,0.3); margin-right: 4px; cursor: pointer;"></button>
                        <button onclick="applyColorPreset('grayscale', 4)" style="width: 20px; height: 20px; background: hsl(0, 0%, 0%); border: 1px solid rgba(255,255,255,0.3); cursor: pointer;"></button>
                    </div>
                </div>

                <!-- Buttons -->
                <div style="display: flex; gap: 8px; margin-top: 20px;">
                    <button onclick="saveColorFromPicker()" style="flex: 1; padding: 10px; background: var(--primary); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">APPLY COLOR</button>
                    <button onclick="resetTagColor(document.getElementById('colorPickerModal').dataset.tagPath); document.getElementById('colorPickerModal').classList.remove('active');" style="flex: 1; padding: 10px; background: rgba(255, 0, 110, 0.2); color: var(--accent); border: 1px solid var(--accent); border-radius: 4px; cursor: pointer; font-weight: bold;">AUTO COLOR</button>
                </div>
            </div>
        </div>

        <!-- Bulk Operations Panel (Phase 3c) -->
        <div id="bulkOperationsPanel" style="display: none; flex-wrap: wrap; gap: 12px; align-items: center; padding: 12px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px; margin-bottom: 16px;">
            <span id="bulkSelectionCounter" style="color: var(--primary); font-weight: bold; min-width: 120px;"></span>
            <button onclick="openBulkModal('add')" style="padding: 6px 12px; background: rgba(0, 212, 255, 0.2); border: 1px solid var(--primary); color: var(--primary); border-radius: 4px; cursor: pointer; font-size: 0.85rem;">+ ADD TAG</button>
            <button onclick="openBulkModal('remove')" style="padding: 6px 12px; background: rgba(255, 0, 110, 0.2); border: 1px solid var(--accent); color: var(--accent); border-radius: 4px; cursor: pointer; font-size: 0.85rem;">- REMOVE TAG</button>
            <button onclick="openBulkModal('replace')" style="padding: 6px 12px; background: rgba(255, 170, 0, 0.2); border: 1px solid var(--warning); color: var(--warning); border-radius: 4px; cursor: pointer; font-size: 0.85rem;"> REPLACE TAG</button>
            <button onclick="bulkClearTags()" style="padding: 6px 12px; background: rgba(255, 0, 110, 0.2); border: 1px solid var(--accent); color: var(--accent); border-radius: 4px; cursor: pointer; font-size: 0.85rem;"> CLEAR ALL</button>
            <button onclick="deselectAllTasks()" style="padding: 6px 12px; background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--text-secondary); border-radius: 4px; cursor: pointer; font-size: 0.85rem; margin-left: auto;">DESELECT ALL</button>
        </div>

        <!-- Tag Suggestions Container (Phase 3d) -->
        <div id="tagSuggestionsContainer"></div>

        <!-- Cloud Sync Modal (Phase 3e) -->
        <div id="cloudSyncModal" class="modal" style="z-index: 2000;">
            <div class="modal-content" style="max-width: 450px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3 style="margin: 0;">Cloud Sync Settings</h3>
                    <button onclick="closeCloudSyncSettings()" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-secondary);"></button>
                </div>

                <!-- Connection Status -->
                <div id="cloudSyncStatusDisplay" style="padding: 12px; background: rgba(0, 212, 255, 0.1); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 4px; margin-bottom: 16px; color: var(--text-secondary); font-size: 0.9rem;">
                    Not connected to Google Drive
                </div>

                <!-- Connection Buttons -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                    <button onclick="connectCloudSync()" id="cloudConnectBtn" style="flex: 1; padding: 10px; background: var(--success); color: var(--bg-dark); border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">CONNECT GOOGLE DRIVE</button>
                    <button onclick="disconnectCloudSync()" id="cloudDisconnectBtn" style="flex: 1; padding: 10px; background: var(--accent); color: var(--bg-darker); border: none; border-radius: 4px; cursor: pointer; font-weight: bold; display: none;">DISCONNECT</button>
                </div>

                <!-- Sync Interval Selection -->
                <div style="margin-bottom: 16px;">
                    <label style="display: block; margin-bottom: 8px; font-size: 0.9rem; color: var(--text-secondary);">SYNC INTERVAL:</label>
                    <select onchange="setSyncInterval(this.value)" style="width: 100%; padding: 8px; background: var(--bg-darker); color: var(--text-primary); border: 1px solid rgba(0, 212, 255, 0.3); border-radius: 4px; cursor: pointer;">
                        <option value="manual">Manual (Click "Sync Now")</option>
                        <option value="hourly">Hourly</option>
                        <option value="daily">Daily</option>
                    </select>
                </div>

                <!-- Manual Sync Buttons -->
                <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                    <button onclick="triggerManualSync()" style="flex: 1; padding: 10px; background: rgba(0, 212, 255, 0.2); border: 1px solid var(--primary); color: var(--primary); border-radius: 4px; cursor: pointer; font-weight: bold;"> SYNC NOW</button>
                    <button onclick="triggerManualDownload()" style="flex: 1; padding: 10px; background: rgba(0, 212, 255, 0.2); border: 1px solid var(--primary); color: var(--primary); border-radius: 4px; cursor: pointer; font-weight: bold;"> DOWNLOAD</button>
                </div>

                <!-- Sync Status -->
                <div style="text-align: center; font-size: 0.85rem; color: var(--text-secondary);">
                    <span id="syncStatusIndicator">Ready</span>
                </div>

                <!-- Help Text -->
                <div style="margin-top: 16px; padding: 12px; background: rgba(0, 212, 255, 0.05); border-left: 3px solid var(--primary); border-radius: 2px; font-size: 0.85rem; color: var(--text-secondary);">
                    <strong>Cloud Sync:</strong> Backup and synchronize your Life OS data with Google Drive. Your data stays private - Life OS only has access to files it creates. Syncing is optional and can be disabled anytime.
                </div>
            </div>
        </div>

        <footer>
             LOCAL PERSISTENT STORAGE //  OFFLINE CAPABLE //  FULLY RESPONSIVE<br>
            LIFE OS v2.0 // COMMAND CENTER MODE // ALL SYSTEMS NOMINAL
        </footer>
    </div>

    <script>
        const STORAGE_KEYS = {
            afr: 'life-os-afr-tasks',
            uxr: 'life-os-uxr-tasks',
            domains: 'life-os-domain-items'
        };

        // ============================================
        // STORAGE VALIDATION & ERROR HANDLING UTILITIES
        // ============================================

        /**
         * Check if localStorage is available and functional
         * @returns {boolean} True if localStorage is available
         */
        function isStorageAvailable() {
            try {
                const test = '__localStorage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch(e) {
                console.error('localStorage is not available:', e);
                return false;
            }
        }

        /**
         * Validate task data structure
         * @param {object} task - Task object to validate
         * @returns {boolean} True if task has valid structure
         */
        function isValidTask(task) {
            if (!task || typeof task !== 'object') return false;

            // Check required fields
            if (typeof task.label !== 'string' || !task.label.trim()) return false;
            if (typeof task.completed !== 'boolean') return false;
            if (typeof task.priority !== 'string') return false;
            if (!['high', 'medium', 'low'].includes(task.priority)) return false;
            if (typeof task.estimate !== 'number' || task.estimate < 0) return false;
            if (typeof task.createdAt !== 'number' || task.createdAt < 0) return false;

            // Optional fields validation
            if (task.recurrence && !['none', 'daily', 'weekly', 'monthly'].includes(task.recurrence)) return false;
            if (task.notes && typeof task.notes !== 'string') return false;
            if (task.subtasks && !Array.isArray(task.subtasks)) return false;
            if (task.dueDate && typeof task.dueDate !== 'number') return false;

            return true;
        }

        // ============================================
        // TAG SYSTEM FUNCTIONS (Phase 1a-1i)
        // ============================================

        /**
         * Get all tags from global registry
         * @returns {Array} Array of tag objects
         */
        function getAllTags() {
            try {
                if (!isStorageAvailable()) return [];
                const data = localStorage.getItem('life-os-tags-registry');
                if (!data) return [];
                const registry = JSON.parse(data);
                return registry.tags || [];
            } catch (error) {
                console.error('Error getting tags:', error);
                return [];
            }
        }

        /**
         * Create a new tag if it doesn't exist
         * @param {string} tagName - Tag name (max 25 chars)
         * @returns {boolean} Success status
         */
        function createTag(tagName) {
            try {
                if (!isStorageAvailable()) return false;

                // Validate tag name
                if (!tagName || tagName.length > 25 || !/^[a-z0-9\-_]+$/i.test(tagName)) {
                    console.error('Invalid tag name:', tagName);
                    return false;
                }

                let registry = { tags: [] };
                try {
                    const data = localStorage.getItem('life-os-tags-registry');
                    if (data) registry = JSON.parse(data);
                } catch (e) {
                    console.warn('Could not parse tag registry, starting fresh');
                }

                // Check if tag already exists (case-insensitive)
                const lowerName = tagName.toLowerCase();
                const exists = registry.tags.some(t => t.name.toLowerCase() === lowerName);
                if (exists) return true; // Already exists

                // Add new tag
                registry.tags.push({
                    name: tagName.toLowerCase(),
                    createdAt: Date.now(),
                    archived: false
                });

                // Save to storage
                if (!setStorageData('life-os-tags-registry', registry)) {
                    console.error('Failed to save tag registry');
                    return false;
                }

                console.log(`Created tag: ${tagName}`);
                return true;
            } catch (error) {
                console.error('Error creating tag:', error);
                return false;
            }
        }

        /**
         * Validate tag name format
         * @param {string} tagName - Tag name to validate
         * @returns {boolean} Is valid
         */
        function isValidTagName(tagName) {
            return tagName &&
                   tagName.length <= 25 &&
                   /^[a-z0-9\-_]+$/i.test(tagName);
        }

        /**
         * Get deterministic color for a tag
         * @param {string} tagName - Tag name
         * @returns {string} CSS color
         */
        function getTagColor(tagName) {
            const colors = [
                '#00d4ff', '#ff006e', '#00ff88', '#0099ff', '#ffaa00',
                '#ff4400', '#00cc99', '#cc00ff', '#ffcc00', '#00ffcc',
                '#ff0099', '#0066ff', '#00ff66', '#ff6600', '#00ccff'
            ];

            let hash = 0;
            for (let i = 0; i < tagName.length; i++) {
                hash = ((hash << 5) - hash) + tagName.charCodeAt(i);
                hash = hash & hash;
            }

            const colorIndex = Math.abs(hash) % colors.length;
            return colors[colorIndex];
        }

        /**
         * Get usage count for a tag
         * @param {string} tagName - Tag name
         * @returns {number} Number of tasks with this tag
         */
        function getTagUsageCount(tagName) {
            let count = 0;

            modules.forEach(module => {
                const projects = getProjects(module.storageKey);
                projects.forEach(project => {
                    const tasks = project.tasks || {};
                    Object.values(tasks).forEach(task => {
                        if (task.tags && task.tags.includes(tagName.toLowerCase())) {
                            count++;
                        }
                    });
                });
            });

            return count;
        }

        /**
         * Add a tag to a task
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} taskId - Task ID
         * @param {string} tagName - Tag name to add
         * @returns {boolean} Success status
         */
        function addTagToTask(storageKey, projectId, taskId, tagName) {
            try {
                if (!isValidTagName(tagName)) {
                    console.error('Invalid tag name:', tagName);
                    return false;
                }

                const tagLower = tagName.toLowerCase();
                const data = getStorageData(storageKey);
                if (!data) return false;

                const task = data.projects?.[projectId]?.tasks?.[taskId];
                if (!task) {
                    console.error(`Task not found: ${taskId}`);
                    return false;
                }

                // Initialize tags if missing
                if (!Array.isArray(task.tags)) {
                    task.tags = [];
                }

                // Prevent duplicates
                if (task.tags.some(t => t.toLowerCase() === tagLower)) {
                    console.warn(`Tag already exists on task: ${tagName}`);
                    return true; // Not an error, just no change
                }

                // Enforce max 3 tags per task
                if (task.tags.length >= 3) {
                    console.warn('Task already has maximum tags (3)');
                    return false;
                }

                // Add tag to task
                task.tags.push(tagLower);

                // Create tag globally if not exists
                createTag(tagName);

                // Save to storage
                if (!setStorageData(storageKey, data)) {
                    console.error('Failed to save tag to task');
                    return false;
                }

                console.log(`Added tag "${tagName}" to task ${taskId}`);
                return true;
            } catch (error) {
                console.error('Error adding tag to task:', error);
                return false;
            }
        }

        /**
         * Remove a tag from a task
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} taskId - Task ID
         * @param {string} tagName - Tag name to remove
         * @returns {boolean} Success status
         */
        function removeTagFromTask(storageKey, projectId, taskId, tagName) {
            try {
                const tagLower = tagName.toLowerCase();
                const data = getStorageData(storageKey);
                if (!data) return false;

                const task = data.projects?.[projectId]?.tasks?.[taskId];
                if (!task || !Array.isArray(task.tags)) {
                    return false;
                }

                const initialLength = task.tags.length;
                task.tags = task.tags.filter(t => t.toLowerCase() !== tagLower);

                if (task.tags.length === initialLength) {
                    console.warn(`Tag not found on task: ${tagName}`);
                    return false;
                }

                // Save to storage
                if (!setStorageData(storageKey, data)) {
                    console.error('Failed to save after removing tag');
                    return false;
                }

                console.log(`Removed tag "${tagName}" from task ${taskId}`);
                return true;
            } catch (error) {
                console.error('Error removing tag from task:', error);
                return false;
            }
        }

        /**
         * Remove tag from task and update UI (for inline tag input)
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} taskId - Task ID
         * @param {string} tagName - Tag name to remove
         */
        function removeTagFromTaskUI(storageKey, projectId, taskId, tagName) {
            UndoRedoManager.saveState('Remove tag');
            if (removeTagFromTask(storageKey, projectId, taskId, tagName)) {
                // Find and update the task card
                const currentModuleForKey = modules.find(m => m.storageKey === storageKey);
                if (currentModuleForKey) {
                    renderDetailView(currentModuleForKey);
                    updateGlobalStats();
                    updateUndoRedoButtons();
                }
            }
        }

        /**
         * Get tag suggestions based on input (for autocomplete)
         * @param {string} input - User input
         * @param {Array} existingTags - Tags already on this task
         * @returns {Array} Suggested tags with usage counts
         */
        function getTagSuggestions(input, existingTags = []) {
            if (!input || input.trim().length === 0) {
                return [];
            }

            const inputLower = input.toLowerCase().trim();
            const allTags = getAllTags();
            const existingTagsLower = existingTags.map(t => t.toLowerCase());

            // Filter tags by input and exclude already-added tags
            const suggestions = allTags
                .filter(tag => {
                    const tagNameLower = tag.name.toLowerCase();
                    return (
                        tagNameLower.includes(inputLower) &&
                        !existingTagsLower.includes(tagNameLower)
                    );
                })
                .map(tag => ({
                    name: tag.name,
                    count: getTagUsageCount(tag.name)
                }))
                // Sort by relevance: starts with input first, then by usage count
                .sort((a, b) => {
                    const aStartsWith = a.name.toLowerCase().startsWith(inputLower);
                    const bStartsWith = b.name.toLowerCase().startsWith(inputLower);
                    if (aStartsWith !== bStartsWith) {
                        return aStartsWith ? -1 : 1;
                    }
                    return b.count - a.count;
                })
                .slice(0, 5); // Limit to 5 suggestions

            return suggestions;
        }

        /**
         * Show autocomplete popup for tag input
         * @param {HTMLElement} inputElement - The tag input element
         * @param {Array} suggestions - Array of suggestion objects
         */
        function showTagAutocomplete(inputElement, suggestions) {
            // Remove existing popup
            hideTagAutocomplete();

            if (!suggestions || suggestions.length === 0) {
                return;
            }

            // Create popup container
            const popup = document.createElement('div');
            popup.className = 'tag-autocomplete-popup';
            popup.style.position = 'absolute';

            // Position popup below input
            const rect = inputElement.getBoundingClientRect();
            popup.style.top = (rect.height + 4) + 'px';
            popup.style.left = '0px';

            // Add suggestions
            suggestions.forEach((suggestion, index) => {
                const item = document.createElement('div');
                item.className = 'tag-suggestion';
                item.innerHTML = `
                    <span class="tag-suggestion-name">${suggestion.name}</span>
                    <span class="tag-suggestion-count">${suggestion.count}</span>
                `;
                item.onclick = (e) => {
                    e.stopPropagation();
                    selectTagSuggestion(suggestion.name, inputElement);
                };
                popup.appendChild(item);
            });

            // Insert popup as sibling and set up container positioning
            inputElement.parentNode.style.position = 'relative';
            inputElement.parentNode.appendChild(popup);
            inputElement.dataset.autocompleteOpen = 'true';
        }

        /**
         * Hide autocomplete popup
         */
        function hideTagAutocomplete() {
            const popup = document.querySelector('.tag-autocomplete-popup');
            if (popup) {
                popup.remove();
            }
            const openInputs = document.querySelectorAll('[data-autocomplete-open="true"]');
            openInputs.forEach(input => {
                delete input.dataset.autocompleteOpen;
            });
        }

        /**
         * Select tag from suggestion and add to task
         * @param {string} tagName - Tag name to add
         * @param {HTMLElement} inputElement - The tag input element
         */
        function selectTagSuggestion(tagName, inputElement) {
            const storageKey = inputElement.dataset.storageKey;
            const projectId = inputElement.dataset.projectId;
            const taskId = inputElement.dataset.taskId;

            if (!storageKey || !projectId || !taskId) {
                console.error('Missing data attributes on tag input');
                return;
            }

            UndoRedoManager.saveState('Add tag');
            if (addTagToTask(storageKey, projectId, taskId, tagName)) {
                // Update UI
                const currentModuleForKey = modules.find(m => m.storageKey === storageKey);
                if (currentModuleForKey) {
                    renderDetailView(currentModuleForKey);
                    updateGlobalStats();
                    updateUndoRedoButtons();
                }
            }

            hideTagAutocomplete();
        }

        /**
         * Filter tasks by tags (AND logic)
         * @param {Array} tasks - Task objects to filter
         * @param {Array} selectedTags - Tag names to match (all must be present)
         * @returns {Array} Filtered tasks
         */
        function filterTasksByTags(tasks, selectedTags) {
            if (!selectedTags || selectedTags.length === 0) {
                return tasks; // No tag filter
            }

            const tagsLower = selectedTags.map(t => t.toLowerCase());

            return tasks.filter(task => {
                if (!task.tags || !Array.isArray(task.tags)) {
                    return false; // Task without tags doesn't match
                }

                // Check if task has ALL selected tags (AND logic)
                return tagsLower.every(selectedTag =>
                    task.tags.some(taskTag => taskTag.toLowerCase() === selectedTag)
                );
            });
        }

        /**
         * Migrate legacy tasks to include tags field
         * Runs automatically if tasks exist without tags
         */
        function migrateTasksToIncludeTags() {
            let migrationCount = 0;

            modules.forEach(module => {
                try {
                    const data = getStorageData(module.storageKey);
                    if (!data) return;

                    const projects = data.projects || {};
                    let modified = false;

                    Object.values(projects).forEach(project => {
                        const tasks = project.tasks || {};
                        Object.values(tasks).forEach(task => {
                            // If task doesn't have tags field, add it
                            if (!Array.isArray(task.tags)) {
                                task.tags = [];
                                modified = true;
                                migrationCount++;
                            }
                        });
                    });

                    // Save if modified
                    if (modified) {
                        setStorageData(module.storageKey, data);
                        console.log(`Migrated ${migrationCount} tasks to include tag support for ${module.id}`);
                    }
                } catch (error) {
                    console.error(`Error migrating tags for ${module.id}:`, error);
                }
            });

            return migrationCount;
        }

        /**
         * Sanitize and repair corrupted task data
         * @param {object} task - Potentially corrupted task
         * @returns {object} Repaired task object
         */
        function repairTaskData(task) {
            if (typeof task !== 'object' || !task) {
                return null;
            }

            // If it's just a boolean (legacy format), skip it
            if (typeof task === 'boolean') {
                return null;
            }

            const repaired = {
                label: (typeof task.label === 'string' && task.label.trim()) ? task.label : 'TASK',
                completed: typeof task.completed === 'boolean' ? task.completed : false,
                priority: ['high', 'medium', 'low'].includes(task.priority) ? task.priority : 'medium',
                estimate: (typeof task.estimate === 'number' && task.estimate >= 0) ? task.estimate : 1,
                createdAt: (typeof task.createdAt === 'number' && task.createdAt > 0) ? task.createdAt : Date.now(),
                dueDate: (typeof task.dueDate === 'number' && task.dueDate > 0) ? task.dueDate : Date.now(),
                recurrence: (task.recurrence && ['daily', 'weekly', 'monthly'].includes(task.recurrence)) ? task.recurrence : 'none'
            };

            // Preserve optional fields if valid
            if (typeof task.notes === 'string') {
                repaired.notes = task.notes;
            }
            if (Array.isArray(task.subtasks)) {
                repaired.subtasks = task.subtasks.filter(st =>
                    st && typeof st === 'object' && typeof st.label === 'string'
                );
            }

            return repaired;
        }

        /**
         * Safe localStorage retrieval with error handling and validation
         * @param {string} key - Storage key
         * @returns {object} Parsed and validated data, or empty object if unavailable
         */
        function getStorageData(key) {
            try {
                if (!isStorageAvailable()) {
                    console.warn('localStorage not available, returning empty data');
                    return {};
                }

                const data = localStorage.getItem(key);
                if (!data) {
                    return {};
                }

                let parsed;
                try {
                    parsed = JSON.parse(data);
                } catch(e) {
                    console.error(`Failed to parse data for key "${key}":`, e);
                    // Clear corrupted data
                    try {
                        localStorage.removeItem(key);
                    } catch(clearError) {
                        console.error('Failed to clear corrupted data:', clearError);
                    }
                    return {};
                }

                // Check if this is the new project-based structure
                const isProjectStructure = parsed.projects && typeof parsed.projects === 'object' && Object.keys(parsed).length === 1;

                if (isProjectStructure) {
                    // New project-based structure - don't validate, just return it
                    return parsed;
                }

                // Validate and repair task data (old flat structure)
                if (typeof parsed === 'object' && parsed !== null && !Array.isArray(parsed)) {
                    const validated = {};
                    let repairsNeeded = false;

                    for (const [taskId, taskData] of Object.entries(parsed)) {
                        if (isValidTask(taskData)) {
                            validated[taskId] = taskData;
                        } else {
                            const repaired = repairTaskData(taskData);
                            if (repaired) {
                                validated[taskId] = repaired;
                                repairsNeeded = true;
                            }
                        }
                    }

                    // Save repaired data back to storage
                    if (repairsNeeded) {
                        try {
                            localStorage.setItem(key, JSON.stringify(validated));
                            console.warn(`Repaired corrupted data for key "${key}"`);
                        } catch(saveError) {
                            console.error('Failed to save repaired data:', saveError);
                        }
                    }

                    return validated;
                }

                return {};
            } catch(error) {
                console.error(`Error retrieving storage data for key "${key}":`, error);
                return {};
            }
        }

        /**
         * Safe localStorage setting with quota and error handling
         * @param {string} key - Storage key
         * @param {object} data - Data to store
         * @returns {boolean} True if storage was successful
         */
        function setStorageData(key, data) {
            try {
                if (!isStorageAvailable()) {
                    console.warn('localStorage not available, cannot save data');
                    return false;
                }

                const jsonString = JSON.stringify(data);

                // Check if data is too large (rough estimate)
                if (jsonString.length > 5 * 1024 * 1024) {
                    console.error('Data exceeds storage limit (5MB)');
                    return false;
                }

                localStorage.setItem(key, jsonString);
                return true;
            } catch(error) {
                if (error.name === 'QuotaExceededError' || error.message.includes('quota')) {
                    console.error(`Storage quota exceeded for key "${key}"`);
                    // Could implement cleanup strategy here (e.g., remove old data)
                } else {
                    console.error(`Error saving storage data for key "${key}":`, error);
                }
                return false;
            }
        }

        /**
         * Get storage capacity information
         * @returns {object} Storage stats including used and available space
         */
        function getStorageStats() {
            try {
                const testKey = '__storage_test__';
                const testData = 'test';

                // Try to estimate available storage
                let totalUsed = 0;
                modules.forEach(module => {
                    const data = localStorage.getItem(module.storageKey);
                    if (data) {
                        totalUsed += data.length;
                    }
                });

                // Add undo/redo stack size estimation
                const undoRedoEstimate = JSON.stringify({
                    undoStack: [],
                    redoStack: []
                }).length;

                const estimatedTotal = totalUsed + undoRedoEstimate;
                const quotaMB = estimatedTotal / (1024 * 1024);

                return {
                    estimatedUsedBytes: estimatedTotal,
                    estimatedUsedMB: quotaMB.toFixed(2),
                    moduleBreakdown: modules.map(m => ({
                        name: m.name,
                        bytes: localStorage.getItem(m.storageKey)?.length || 0
                    }))
                };
            } catch (error) {
                console.error('Error calculating storage stats:', error);
                return null;
            }
        }

        /**
         * Validate all storage data across all modules
         * @returns {object} Validation report with counts of issues found
         */
        function validateAllStorage() {
            const report = {
                modulesChecked: 0,
                tasksValidated: 0,
                tasksCorrected: 0,
                errors: []
            };

            modules.forEach(module => {
                report.modulesChecked++;
                const data = getStorageData(module.storageKey);
                const taskCount = Object.keys(data).length;
                report.tasksValidated += taskCount;
            });

            return report;
        }

        // ============================================
        // PROJECT MANAGEMENT FUNCTIONS
        // ============================================

        /**
         * Migrate old task format to project-based format
         * @param {string} storageKey - Module storage key
         */
        function migrateToProjects(storageKey) {
            try {
                const oldData = localStorage.getItem(storageKey);

                // If no data exists, initialize with empty projects structure
                if (!oldData) {
                    const newStructure = { projects: {} };
                    localStorage.setItem(storageKey, JSON.stringify(newStructure));
                    return;
                }

                const parsed = JSON.parse(oldData);

                // Check if already properly migrated (has projects structure only with no corruption)
                if (parsed.projects && Object.keys(parsed).length === 1) {
                    // Extra validation: check that projects only contains project IDs
                    const projectsObj = parsed.projects;
                    const hasCorruption = Object.keys(projectsObj).some(key => {
                        // Valid project keys start with 'proj_' or are 'general'
                        if (key === 'general' || key.startsWith('proj_')) return false;
                        // Any other keys indicate corruption
                        return true;
                    });

                    if (!hasCorruption) {
                        return; // Already properly migrated
                    }
                }

                // Check if empty
                if (Object.keys(parsed).length === 0) {
                    // Initialize with empty projects structure
                    const newStructure = { projects: {} };
                    localStorage.setItem(storageKey, JSON.stringify(newStructure));
                    return;
                }

                // Detect if we have projects to preserve
                const projectIds = new Set();
                Object.keys(parsed).forEach(key => {
                    if (key.startsWith('proj_')) {
                        projectIds.add(key);
                    }
                });

                // CRITICAL: If projects object exists with mixed data, extract corrupted properties
                if (parsed.projects && typeof parsed.projects === 'object') {
                    const projectsObj = parsed.projects;
                    const hasTaskProperties = ['label', 'completed', 'priority', 'estimate', 'createdAt', 'dueDate', 'recurrence'].some(
                        prop => prop in projectsObj
                    );

                    if (hasTaskProperties) {
                        // Projects object is corrupted with old task properties mixed in
                        console.log(`Fixing corrupted projects object for ${storageKey}`);

                        const newStructure = { projects: {} };
                        const corruptedTask = {};
                        const cleanProjects = {};

                        // Separate task properties from project objects
                        Object.entries(projectsObj).forEach(([key, value]) => {
                            if (key.startsWith('proj_') || key === 'general') {
                                // This is a valid project
                                if (typeof value === 'object' && value.id) {
                                    cleanProjects[key] = value;
                                }
                            } else if (['label', 'completed', 'priority', 'estimate', 'createdAt', 'dueDate', 'recurrence'].includes(key)) {
                                // This is a corrupted task property
                                corruptedTask[key] = value;
                            }
                        });

                        // Add clean projects
                        Object.assign(newStructure.projects, cleanProjects);

                        // Add corrupted task to General project if it has content
                        if (Object.keys(corruptedTask).length > 0) {
                            newStructure.projects['general'] = {
                                id: 'general',
                                name: 'General',
                                createdAt: Date.now(),
                                tasks: { 'legacy_task': corruptedTask }
                            };
                        }

                        localStorage.setItem(storageKey, JSON.stringify(newStructure));
                        console.log(`Fixed corrupted projects object for ${storageKey}`);
                        return;
                    }
                }

                // Extract old tasks (anything that's not a project ID)
                const oldTasks = {};

                Object.entries(parsed).forEach(([key, value]) => {
                    if (!key.startsWith('proj_') && key !== 'projects') {
                        if (typeof value === 'object' && value !== null && (value.label || value.completed !== undefined || value.priority)) {
                            oldTasks[key] = value;
                        }
                    }
                });

                // If there are projects already, restructure
                if (projectIds.size > 0) {
                    console.log(`Fixing mixed-format data for ${storageKey}, found ${projectIds.size} projects and ${Object.keys(oldTasks).length} old tasks`);

                    const newStructure = { projects: {} };

                    // Add any old tasks to "General" project
                    if (Object.keys(oldTasks).length > 0) {
                        newStructure.projects['general'] = {
                            id: 'general',
                            name: 'General',
                            createdAt: Date.now(),
                            tasks: oldTasks
                        };
                    }

                    // Add existing projects
                    projectIds.forEach(projectId => {
                        if (parsed[projectId]) {
                            newStructure.projects[projectId] = parsed[projectId];
                        }
                    });

                    localStorage.setItem(storageKey, JSON.stringify(newStructure));
                    console.log(`Fixed mixed-format data for ${storageKey}`);
                    return;
                }

                // Migrate old tasks to "General" project
                const newStructure = {
                    projects: {
                        'general': {
                            id: 'general',
                            name: 'General',
                            createdAt: Date.now(),
                            tasks: parsed
                        }
                    }
                };

                localStorage.setItem(storageKey, JSON.stringify(newStructure));
                console.log(`Migrated tasks to projects for ${storageKey}`);
            } catch (error) {
                console.error(`Migration failed for ${storageKey}:`, error);
                // Emergency reset: clear the corrupted data
                localStorage.removeItem(storageKey);
                const newStructure = { projects: {} };
                localStorage.setItem(storageKey, JSON.stringify(newStructure));
                console.warn(`Emergency reset performed for ${storageKey}`);
            }
        }

        /**
         * Get all projects for a module
         * @param {string} storageKey - Module storage key
         * @returns {array} Array of project objects
         */
        function getProjects(storageKey) {
            try {
                migrateToProjects(storageKey); // Ensure migrated format
                const data = getStorageData(storageKey);
                const projects = data.projects || {};
                return Object.values(projects).sort((a, b) => a.createdAt - b.createdAt);
            } catch (error) {
                console.error(`Error getting projects for ${storageKey}:`, error);
                return [];
            }
        }

        /**
         * Get all tasks in a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @returns {object} Tasks object
         */
        function getProjectTasks(storageKey, projectId) {
            try {
                const data = getStorageData(storageKey);
                const project = data.projects?.[projectId];
                return project?.tasks || {};
            } catch (error) {
                console.error(`Error getting tasks for project ${projectId}:`, error);
                return {};
            }
        }

        /**
         * Create a new project
         * @param {string} storageKey - Module storage key
         * @param {string} projectName - Name of the project
         * @returns {string} Project ID
         */
        function createProject(storageKey, projectName) {
            try {
                console.log(`Creating project "${projectName}" in ${storageKey}`);

                // CRITICAL: Save undo state BEFORE any modifications to ensure state consistency
                UndoRedoManager.saveState(`Create project "${projectName}"`);

                // CRITICAL: Ensure data is properly migrated FIRST
                migrateToProjects(storageKey);

                const data = getStorageData(storageKey);
                const projectId = 'proj_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

                if (!data.projects) {
                    data.projects = {};
                }

                data.projects[projectId] = {
                    id: projectId,
                    name: projectName,
                    createdAt: Date.now(),
                    tasks: {}
                };

                console.log(`Attempting to save project ${projectId} to storage`);

                // Verify save was successful before returning
                if (!setStorageData(storageKey, data)) {
                    console.error(`CRITICAL: Failed to save project to storage for ${storageKey}`);
                    const stats = getStorageStats();
                    if (stats) {
                        console.error('Storage stats:', stats);
                    }
                    return null;
                }

                console.log(`Project ${projectId} created successfully`);

                updateUndoRedoButtons();
                return projectId;
            } catch (error) {
                console.error(`Error creating project in ${storageKey}:`, error);
                const stats = getStorageStats();
                if (stats) {
                    console.error('Storage stats:', stats);
                }
                updateUndoRedoButtons();
                return null;
            }
        }

        /**
         * Delete a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         */
        function deleteProject(storageKey, projectId) {
            try {
                UndoRedoManager.saveState(`Delete project`);

                const data = getStorageData(storageKey);
                if (data.projects?.[projectId]) {
                    delete data.projects[projectId];
                    setStorageData(storageKey, data);
                    updateUndoRedoButtons();
                }
            } catch (error) {
                console.error(`Error deleting project ${projectId}:`, error);
            }
        }

        /**
         * Rename a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} newName - New project name
         */
        function renameProject(storageKey, projectId, newName) {
            try {
                UndoRedoManager.saveState(`Rename project to "${newName}"`);

                const data = getStorageData(storageKey);
                if (data.projects?.[projectId]) {
                    data.projects[projectId].name = newName;
                    setStorageData(storageKey, data);
                    updateUndoRedoButtons();
                }
            } catch (error) {
                console.error(`Error renaming project ${projectId}:`, error);
            }
        }

        /**
         * Add a task to a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {object} taskData - Task object
         */
        function addTaskToProject(storageKey, projectId, taskData) {
            try {
                console.log(`Adding task to project ${projectId}`);

                const data = getStorageData(storageKey);
                const project = data.projects?.[projectId];

                if (!project) {
                    console.error(`Project ${projectId} not found in storage. Available keys:`, Object.keys(data.projects || {}));
                    return null;
                }

                if (!project.tasks) {
                    project.tasks = {};
                }

                const taskId = 'task_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                project.tasks[taskId] = {
                    ...taskData,
                    id: taskId,
                    createdAt: taskData.createdAt || Date.now()
                };

                console.log(`Saving task ${taskId} to storage`);

                if (!setStorageData(storageKey, data)) {
                    console.error(`CRITICAL: Failed to save task to storage for project ${projectId}`);
                    const stats = getStorageStats();
                    if (stats) {
                        console.error('Storage stats:', stats);
                    }
                    return null;
                }

                console.log(`Task ${taskId} created successfully`);

                // Save undo state AFTER successful creation
                try {
                    UndoRedoManager.saveState(`Add task to project`);
                } catch (undoError) {
                    console.warn('Undo/redo save failed (non-critical):', undoError);
                }

                updateUndoRedoButtons();
                return taskId;
            } catch (error) {
                console.error(`Error adding task to project ${projectId}:`, error);
                const stats = getStorageStats();
                if (stats) {
                    console.error('Storage stats:', stats);
                }
                return null;
            }
        }

        /**
         * Delete a task from a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} taskId - Task ID
         */
        function deleteTaskFromProject(storageKey, projectId, taskId) {
            try {
                const data = getStorageData(storageKey);
                const project = data.projects?.[projectId];

                if (project?.tasks?.[taskId]) {
                    delete project.tasks[taskId];

                    // Only save undo state if storage succeeds
                    if (!setStorageData(storageKey, data)) {
                        console.error('Failed to delete task');
                        return false;
                    }

                    UndoRedoManager.saveState(`Delete task`);
                    updateUndoRedoButtons();
                    return true;
                }
                return false;
            } catch (error) {
                console.error(`Error deleting task from project ${projectId}:`, error);
                return false;
            }
        }

        /**
         * Update a task in a project
         * @param {string} storageKey - Module storage key
         * @param {string} projectId - Project ID
         * @param {string} taskId - Task ID
         * @param {object} updates - Fields to update
         */
        function updateTaskInProject(storageKey, projectId, taskId, updates) {
            try {
                const data = getStorageData(storageKey);
                const task = data.projects?.[projectId]?.tasks?.[taskId];

                if (!task) {
                    console.error(`Task ${taskId} not found in project ${projectId}`);
                    return false;
                }

                Object.assign(task, updates);

                // Only save undo state if storage succeeds
                if (!setStorageData(storageKey, data)) {
                    console.error('Failed to update task');
                    return false;
                }

                UndoRedoManager.saveState(`Update task`);
                updateUndoRedoButtons();
                return true;
            } catch (error) {
                console.error(`Error updating task in project ${projectId}:`, error);
                return false;
            }
        }

        // ============================================
        // URL PARAMETER UTILITIES
        // ============================================

        /**
         * Parse URL parameters into an object
         * @returns {object} Parsed URL parameters
         */
        function getURLParameters() {
            const params = {};
            const queryString = window.location.search.substring(1);

            if (queryString) {
                const pairs = queryString.split('&');
                pairs.forEach(pair => {
                    const [key, value] = pair.split('=');
                    if (key) {
                        params[decodeURIComponent(key)] = value ? decodeURIComponent(value) : '';
                    }
                });
            }

            return params;
        }

        /**
         * Update URL without reloading page
         * @param {object} params - Parameters to set in URL
         */
        function updateURL(params) {
            try {
                const queryString = Object.keys(params)
                    .filter(key => params[key])
                    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
                    .join('&');

                const url = queryString ? `${window.location.pathname}?${queryString}` : window.location.pathname;
                window.history.replaceState({}, '', url);
            } catch(error) {
                console.error('Error updating URL:', error);
            }
        }

        /**
         * Get a single URL parameter value
         * @param {string} key - Parameter key
         * @param {string} defaultValue - Default if not found
         * @returns {string} Parameter value
         */
        function getURLParam(key, defaultValue = '') {
            const params = getURLParameters();
            return params[key] || defaultValue;
        }

        // ============================================
        // USER & CREDENTIAL SYSTEM
        // ============================================

        /**
         * User and Credential Management
         * Scaffolded for multi-user support in future
         */
        const UserSystem = (() => {
            const STORAGE_KEY = 'life-os-current-user';
            const DEFAULT_USER = {
                id: 'default',
                name: 'Default User',
                credentialLevel: 'admin'  // 'admin' | 'editor' | 'viewer'
            };

            /**
             * Get current user from localStorage
             * @returns {object} Current user object
             */
            function getCurrentUser() {
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) {
                        const user = JSON.parse(stored);
                        // Validate user has required fields
                        if (user.id && user.name && user.credentialLevel) {
                            return user;
                        }
                    }
                } catch(error) {
                    console.error('Error retrieving user:', error);
                }
                return { ...DEFAULT_USER };
            }

            /**
             * Set current user to localStorage
             * @param {object} user - User object to save
             * @returns {boolean} Success status
             */
            function setCurrentUser(user) {
                try {
                    if (!user.id || !user.name || !user.credentialLevel) {
                        console.error('Invalid user object');
                        return false;
                    }
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(user));
                    return true;
                } catch(error) {
                    console.error('Error saving user:', error);
                    return false;
                }
            }

            /**
             * Check if current user has permission for action
             * @param {string} action - Action to check ('read'|'edit'|'admin')
             * @returns {boolean} True if user has permission
             */
            function hasPermission(action) {
                const user = getCurrentUser();
                const credentialMap = {
                    'admin': ['read', 'edit', 'admin'],
                    'editor': ['read', 'edit'],
                    'viewer': ['read']
                };

                return credentialMap[user.credentialLevel]?.includes(action) || false;
            }

            return {
                getCurrentUser,
                setCurrentUser,
                hasPermission,
                DEFAULT_USER
            };
        })();

        // Initialize current user on page load
        let currentUser = UserSystem.getCurrentUser();

        const modules = [
            { id: 'afr', name: 'Annual Review', icon: '', description: 'Faculty evaluation and self-assessment', storageKey: STORAGE_KEYS.afr, defaultTasks: ['COLLECT TEACHING EVALUATIONS', 'DOCUMENT SERVICE CONTRIBUTIONS', 'COMPILE RESEARCH ACTIVITIES', 'PROFESSIONAL DEVELOPMENT SUMMARY', 'SELF-EVALUATION NARRATIVE', 'GOAL SETTING FOR NEXT CYCLE'] },
            { id: 'uxr', name: 'UXR Lab', icon: '', description: 'User research projects and studies', storageKey: STORAGE_KEYS.uxr, defaultTasks: ['USER RESEARCH PLANNING', 'PARTICIPANT RECRUITMENT', 'CONDUCT INTERVIEWS', 'DATA ANALYSIS', 'FINDINGS DOCUMENTATION', 'PRESENT RESULTS'] },
            { id: 'home', name: 'Home', icon: '', description: 'Household management and operations', storageKey: 'home-domain', defaultTasks: [] },
            { id: 'family', name: 'Family', icon: '', description: 'Family relationships and activities', storageKey: 'family-domain', defaultTasks: [] },
            { id: 'teaching', name: 'PFW Teaching', icon: '', description: 'Course development and engagement', storageKey: 'teaching-domain', defaultTasks: [] },
            { id: 'service', name: 'PFW Service', icon: '', description: 'University committees and obligations', storageKey: 'service-domain', defaultTasks: [] },
            { id: 'bellon', name: 'Bellon Branch', icon: '', description: 'Branch operations and management', storageKey: 'bellon-domain', defaultTasks: [] },
            { id: 'oak', name: 'Olde Oak Tree', icon: '', description: 'Property and asset management', storageKey: 'oak-domain', defaultTasks: [] },
            { id: 'health', name: 'Health', icon: '', description: 'Personal wellness and fitness', storageKey: 'health-domain', defaultTasks: [] }
        ];

        // Undo/Redo State Manager
        const UndoRedoManager = (() => {
            let undoStack = [];
            let redoStack = [];
            const MAX_HISTORY = 50; // Limit history to 50 states

            return {
                saveState: function(description = 'Action') {
                    // Capture current state of all modules
                    const state = {};
                    modules.forEach(m => {
                        state[m.storageKey] = JSON.parse(localStorage.getItem(m.storageKey) || '{}');
                    });

                    undoStack.push({ state, description });
                    redoStack = []; // Clear redo stack when new action is taken

                    // Limit history size
                    if (undoStack.length > MAX_HISTORY) {
                        undoStack = undoStack.slice(undoStack.length - MAX_HISTORY);
                    }

                    updateUndoRedoButtons();
                },

                undo: function() {
                    if (undoStack.length === 0) return false;

                    // Save current state to redo stack
                    const currentState = {};
                    modules.forEach(m => {
                        currentState[m.storageKey] = JSON.parse(localStorage.getItem(m.storageKey) || '{}');
                    });
                    redoStack.push(currentState);

                    // Restore previous state
                    const previousState = undoStack.pop();
                    Object.entries(previousState.state).forEach(([key, data]) => {
                        localStorage.setItem(key, JSON.stringify(data));
                    });

                    updateUndoRedoButtons();
                    return true;
                },

                redo: function() {
                    if (redoStack.length === 0) return false;

                    // Save current state to undo stack
                    const currentState = {};
                    modules.forEach(m => {
                        currentState[m.storageKey] = JSON.parse(localStorage.getItem(m.storageKey) || '{}');
                    });
                    undoStack.push({ state: currentState });

                    // Restore redo state
                    const stateToRestore = redoStack.pop();
                    Object.entries(stateToRestore).forEach(([key, data]) => {
                        localStorage.setItem(key, JSON.stringify(data));
                    });

                    updateUndoRedoButtons();
                    return true;
                },

                canUndo: function() {
                    return undoStack.length > 0;
                },

                canRedo: function() {
                    return redoStack.length > 0;
                },

                clear: function() {
                    undoStack = [];
                    redoStack = [];
                    updateUndoRedoButtons();
                }
            };
        })();

        let currentModule = null;
        let currentFilter = 'all';

        // Tag filtering state
        let currentTagFilters = [];  // Array of selected tag names
        const TAG_FILTER_STORAGE_KEY = 'life-os-tag-filters';

        /**
         * Get saved tag filters
         */
        function getSavedTagFilters() {
            try {
                if (!isStorageAvailable()) return [];
                const saved = localStorage.getItem(TAG_FILTER_STORAGE_KEY);
                return saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading tag filters:', error);
                return [];
            }
        }

        /**
         * Save tag filters state
         */
        function saveTagFiltersState(filters) {
            try {
                if (!isStorageAvailable()) return false;
                localStorage.setItem(TAG_FILTER_STORAGE_KEY, JSON.stringify(filters));
                currentTagFilters = filters;
                return true;
            } catch (error) {
                console.error('Error saving tag filters:', error);
                return false;
            }
        }

        /**
         * Toggle a tag in the filter
         */
        function toggleTagFilter(tagName) {
            const tagLower = tagName.toLowerCase();
            const index = currentTagFilters.findIndex(t => t.toLowerCase() === tagLower);

            if (index >= 0) {
                // Remove tag from filter
                currentTagFilters.splice(index, 1);
            } else {
                // Add tag to filter
                currentTagFilters.push(tagLower);
            }

            saveTagFiltersState(currentTagFilters);

            // Re-render with new filter
            if (currentModule) {
                renderDetailView(currentModule);
            }
        }

        /**
         * Clear all tag filters
         */
        function clearTagFilters() {
            if (currentTagFilters.length === 0) return;

            currentTagFilters = [];
            saveTagFiltersState([]);

            if (currentModule) {
                renderDetailView(currentModule);
            }
        }

        /**
         * Toggle tag sidebar visibility
         */
        function toggleTagSidebar() {
            const sidebar = document.getElementById('tagSidebar');
            const btn = document.getElementById('showTagSidebarBtn');

            if (sidebar.style.display === 'flex') {
                sidebar.style.display = 'none';
                btn.style.display = 'block';
                localStorage.setItem('tag-sidebar-collapsed', 'true');
            } else {
                sidebar.style.display = 'flex';
                btn.style.display = 'none';
                localStorage.setItem('tag-sidebar-collapsed', 'false');
                renderTagSidebar();
            }
        }

        /**
         * Render tag sidebar with all tags
         */
        function renderTagSidebar() {
            const tagsList = document.getElementById('tagsList');
            if (!tagsList) return;

            // Use new hierarchical tree rendering (Phase 3a)
            tagsList.innerHTML = renderTagTree();
        }

        /**
         * Initialize tag sidebar state on page load
         */
        function initializeTagSidebar() {
            const collapsed = localStorage.getItem('tag-sidebar-collapsed') !== 'false';
            const sidebar = document.getElementById('tagSidebar');
            const btn = document.getElementById('showTagSidebarBtn');

            if (collapsed) {
                sidebar.style.display = 'none';
                btn.style.display = 'block';
            } else {
                sidebar.style.display = 'flex';
                btn.style.display = 'none';
                renderTagSidebar();
            }
        }

        function initializeDefaultTasks(module) {
            // Ensure migrated to projects format
            migrateToProjects(module.storageKey);

            const data = getStorageData(module.storageKey);

            // Check if we have any projects and any tasks at all
            const projects = data.projects || {};
            const hasProjects = Object.keys(projects).length > 0;
            const hasTasks = Object.values(projects).some(p => Object.keys(p.tasks || {}).length > 0);

            if (!hasProjects && module.defaultTasks.length > 0) {
                // Create "General" project with default tasks
                const projectId = 'general';
                const projectTasks = {};

                module.defaultTasks.forEach((task, index) => {
                    const taskId = 'task_' + Date.now() + '_' + index;
                    projectTasks[taskId] = {
                        completed: false,
                        priority: 'medium',
                        estimate: 2,
                        label: task,
                        createdAt: Date.now()
                    };
                });

                data.projects[projectId] = {
                    id: projectId,
                    name: 'General',
                    createdAt: Date.now(),
                    tasks: projectTasks
                };

                setStorageData(module.storageKey, data);
            }

            return data;
        }

        function getModuleProgress(module) {
            const projects = getProjects(module.storageKey);
            let totalCompleted = 0;
            let totalTasks = 0;

            projects.forEach(project => {
                const tasks = project.tasks || {};
                const taskIds = Object.keys(tasks);
                totalTasks += taskIds.length;
                totalCompleted += taskIds.filter(id => {
                    const task = tasks[id];
                    return typeof task === 'object' ? task.completed : task;
                }).length;
            });

            return { completed: totalCompleted, total: totalTasks };
        }

        function renderDashboard() {
            const grid = document.getElementById('moduleGrid');
            grid.innerHTML = '';

            modules.forEach(module => {
                const { completed, total } = getModuleProgress(module);
                const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

                const card = document.createElement('div');
                card.className = 'module-card';
                card.setAttribute('data-module-id', module.id);
                card.onclick = () => openModule(module);

                card.innerHTML = `
                    <div class="corner top-left"></div>
                    <div class="corner top-right"></div>
                    <div class="corner bottom-left"></div>
                    <div class="corner bottom-right"></div>

                    <div class="module-header">
                        <div class="module-title">
                            <span class="module-icon">${module.icon}</span>
                            ${module.name}
                        </div>
                    </div>

                    <div class="module-status">
                        <span><span class="status-count">${completed}</span>/${total}</span>
                    </div>

                    <div class="module-mini-progress">
                        <div class="module-mini-fill" style="width: ${percentage}%"></div>
                    </div>

                    <div class="module-description">
                        ${module.description}
                    </div>

                    <div class="module-action">
                        ENTER MODULE 
                    </div>
                `;

                grid.appendChild(card);
            });

            // Also update the sidebar modules list
            renderModulesList();
        }

        /**
         * Render modules list in left sidebar
         */
        function renderModulesList() {
            const modulesList = document.getElementById('modulesList');
            if (!modulesList) return;

            modulesList.innerHTML = '';

            modules.forEach(module => {
                const { completed, total } = getModuleProgress(module);
                const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;

                const item = document.createElement('div');
                item.className = 'module-list-item';
                item.style.cssText = `
                    background: rgba(0, 212, 255, 0.08);
                    border: 1px solid rgba(0, 212, 255, 0.15);
                    border-radius: 4px;
                    padding: 10px 12px;
                    cursor: pointer;
                    transition: all 0.2s ease;
                    font-size: 0.8rem;
                `;

                item.onmouseover = function() {
                    this.style.background = 'rgba(0, 212, 255, 0.15)';
                    this.style.borderColor = 'rgba(0, 212, 255, 0.3)';
                };

                item.onmouseout = function() {
                    this.style.background = 'rgba(0, 212, 255, 0.08)';
                    this.style.borderColor = 'rgba(0, 212, 255, 0.15)';
                };

                item.onclick = () => openModule(module);

                item.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                        <span style="font-size: 1rem;">${module.icon}</span>
                        <span style="color: var(--primary); font-weight: 600; flex: 1;">${module.name}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; font-size: 0.7rem; color: var(--text-secondary);">
                        <span>${completed}/${total}</span>
                        <div style="width: 40px; height: 3px; background: rgba(0, 212, 255, 0.1); border-radius: 2px; overflow: hidden;">
                            <div style="height: 100%; background: var(--primary); width: ${percentage}%; box-shadow: 0 0 10px rgba(0, 212, 255, 0.5);"></div>
                        </div>
                    </div>
                `;

                modulesList.appendChild(item);
            });
        }

        /**
         * Switch between sidebar tabs (MODULES / TAGS)
         */
        function switchSidebarTab(tabName) {
            const modulesTab = document.getElementById('modulesTab');
            const tagsTab = document.getElementById('tagsTab');
            const modulesPanel = document.getElementById('modulesPanel');
            const tagsPanel = document.getElementById('tagsPanel');

            if (tabName === 'modules') {
                // Show modules, hide tags
                modulesTab.classList.add('active');
                tagsTab.classList.remove('active');
                modulesPanel.classList.add('active');
                tagsPanel.classList.remove('active');
                modulesPanel.style.display = 'block';
                tagsPanel.style.display = 'none';
                localStorage.setItem('sidebar-active-tab', 'modules');
            } else if (tabName === 'tags') {
                // Show tags, hide modules
                modulesTab.classList.remove('active');
                tagsTab.classList.add('active');
                modulesPanel.classList.remove('active');
                tagsPanel.classList.add('active');
                modulesPanel.style.display = 'none';
                tagsPanel.style.display = 'block';
                localStorage.setItem('sidebar-active-tab', 'tags');
                // Render tag sidebar when switching to tags
                renderTagSidebar();
            }
        }

        /**
         * Initialize sidebar state on page load
         */
        function initializeSidebar() {
            const lastTab = localStorage.getItem('sidebar-active-tab') || 'modules';
            renderModulesList();

            // Restore the last active tab
            if (lastTab === 'tags') {
                switchSidebarTab('tags');
            } else {
                switchSidebarTab('modules');
            }
        }

        function openModule(module) {
            currentModule = module;
            currentFilter = 'all';  // Reset filter when opening module
            initializeDefaultTasks(module);

            document.getElementById('overviewView').classList.add('hidden-view');
            document.getElementById('detailView').classList.remove('hidden-view');

            document.getElementById('detailIcon').textContent = module.icon;
            document.getElementById('detailName').textContent = module.name;
            document.getElementById('detailInput').placeholder = `// add ${module.name.toLowerCase()} task...`;

            renderDetailView(module);

            // Update URL to reflect current module
            updateURL({
                module: module.id,
                filter: 'all',
                theme: localStorage.getItem('life-os-theme') || 'dark'
            });
        }

        function backToDashboard() {
            currentModule = null;
            document.getElementById('detailView').classList.add('hidden-view');
            document.getElementById('overviewView').classList.remove('hidden-view');

            // Update URL to clear module parameter
            updateURL({
                theme: localStorage.getItem('life-os-theme') || 'dark'
            });
        }

        function renderDetailView(module) {
            const projects = getProjects(module.storageKey);
            let totalCompleted = 0;
            let totalTasks = 0;

            // Calculate aggregate stats across all projects
            projects.forEach(project => {
                const tasks = project.tasks || {};
                const projectTaskIds = Object.keys(tasks);
                totalTasks += projectTaskIds.length;
                totalCompleted += projectTaskIds.filter(id => {
                    const task = tasks[id];
                    return typeof task === 'object' ? task.completed : task;
                }).length;
            });

            const percentage = totalTasks > 0 ? Math.round((totalCompleted / totalTasks) * 100) : 0;

            document.getElementById('detailPercent').textContent = percentage;
            document.getElementById('detailComplete').textContent = totalCompleted;
            document.getElementById('detailTotal').textContent = totalTasks;

            const angle = (percentage / 100) * 360;
            document.getElementById('detailCircle').style.setProperty('--progress-angle', angle + 'deg');

            const checklist = document.getElementById('detailChecklist');
            checklist.innerHTML = '';

            if (projects.length === 0) {
                checklist.innerHTML = `
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px; font-style: italic; margin-bottom: 20px;">
                        NO PROJECTS YET // CREATE YOUR FIRST PROJECT BELOW
                    </div>
                    <button onclick="createNewProject()" style="width: 100%; padding: 12px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--primary); font-weight: 600; border-radius: 4px; cursor: pointer; font-family: 'Space Mono', monospace; margin-bottom: 10px; font-size: 0.85rem;">+ CREATE PROJECT</button>
                `;
            } else {
                projects.forEach(project => {
                    const tasks = project.tasks || {};
                    const projectTaskIds = Object.keys(tasks);
                    const projectCompleted = projectTaskIds.filter(id => {
                        const task = tasks[id];
                        return typeof task === 'object' ? task.completed : task;
                    }).length;
                    const projectPercentage = projectTaskIds.length > 0 ? Math.round((projectCompleted / projectTaskIds.length) * 100) : 0;

                    const projectCard = document.createElement('div');
                    projectCard.className = 'project-card';
                    projectCard.style.cssText = 'border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 6px; margin-bottom: 15px; background: rgba(0, 99, 255, 0.05); overflow: hidden;';

                    projectCard.innerHTML = `
                        <div style="padding: 15px; background: rgba(0, 212, 255, 0.1); border-bottom: 1px solid rgba(0, 212, 255, 0.2); display: flex; align-items: center; justify-content: space-between; cursor: pointer;" onclick="toggleProject(this)">
                            <div style="display: flex; align-items: center; gap: 12px; flex: 1;">
                                <span style="color: var(--primary); font-size: 1.2rem; user-select: none;"></span>
                                <div style="flex: 1;">
                                    <div style="font-weight: 600; color: var(--primary); font-size: 0.95rem;">${project.name}</div>
                                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 3px;">${projectCompleted}/${projectTaskIds.length}  ${projectPercentage}%</div>
                                </div>
                            </div>
                            <div style="display: flex; gap: 8px;">
                                <button class="task-btn edit" data-project-id="${project.id}" style="padding: 5px 10px; font-size: 0.75rem;">RENAME</button>
                                <button class="task-btn delete" data-project-id="${project.id}" data-storage-key="${module.storageKey}" style="padding: 5px 10px; font-size: 0.75rem;">DELETE</button>
                            </div>
                        </div>
                        <div class="project-tasks" style="display: none; padding: 10px;">
                            <!-- Tasks will be rendered here -->
                        </div>
                    `;

                    checklist.appendChild(projectCard);

                    // Add event listeners to buttons (using event delegation to prevent XSS)
                    const renameBtn = projectCard.querySelector('.task-btn.edit');
                    renameBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const projectId = e.target.dataset.projectId;
                        renameProjectUI(projectId);
                    });

                    const deleteBtn = projectCard.querySelector('.task-btn.delete');
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const storageKey = e.target.dataset.storageKey;
                        const projectId = e.target.dataset.projectId;
                        deleteProject(storageKey, projectId);
                        renderDetailView(currentModule);
                    });

                    renderProjectTasks(module.storageKey, project, projectCard.querySelector('.project-tasks'));
                });

                // Add "Create New Project" button
                const createBtn = document.createElement('button');
                createBtn.onclick = () => createNewProject();
                createBtn.style.cssText = 'width: 100%; padding: 12px; background: rgba(0, 212, 255, 0.15); border: 1px solid rgba(0, 212, 255, 0.3); color: var(--primary); font-weight: 600; border-radius: 4px; cursor: pointer; font-family: \'Space Mono\', monospace; margin-top: 10px; font-size: 0.85rem; transition: all 0.3s;';
                createBtn.textContent = '+ CREATE PROJECT';
                createBtn.onmouseover = (e) => {
                    e.target.style.background = 'rgba(0, 212, 255, 0.25)';
                    e.target.style.boxShadow = '0 0 15px rgba(0, 212, 255, 0.2)';
                };
                createBtn.onmouseout = (e) => {
                    e.target.style.background = 'rgba(0, 212, 255, 0.15)';
                    e.target.style.boxShadow = 'none';
                };
                checklist.appendChild(createBtn);
            }
        }

        function renderProjectTasks(storageKey, project, container) {
            const tasks = project.tasks || {};
            const taskIds = Object.keys(tasks);

            if (taskIds.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 15px; font-size: 0.85rem; font-style: italic;">No tasks in this project</div>';
                return;
            }

            let filteredTasks = taskIds;
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());

            if (currentFilter === 'today') {
                filteredTasks = taskIds.filter(id => {
                    const task = tasks[id];
                    if (typeof task === 'object' && task.createdAt) {
                        const taskDate = new Date(task.createdAt);
                        taskDate.setHours(0, 0, 0, 0);
                        return taskDate.getTime() === today.getTime();
                    }
                    return false;
                });
            } else if (currentFilter === 'week') {
                filteredTasks = taskIds.filter(id => {
                    const task = tasks[id];
                    if (typeof task === 'object' && task.createdAt) {
                        const taskDate = new Date(task.createdAt);
                        taskDate.setHours(0, 0, 0, 0);
                        return taskDate >= weekStart && taskDate <= today;
                    }
                    return false;
                });
            } else if (currentFilter === 'high') {
                filteredTasks = taskIds.filter(id => {
                    const task = tasks[id];
                    return typeof task === 'object' ? task.priority === 'high' : false;
                });
            }

            // Apply tag filters (AND logic)
            if (currentTagFilters && currentTagFilters.length > 0) {
                filteredTasks = filteredTasks.filter(id => {
                    const task = tasks[id];
                    if (!task.tags || !Array.isArray(task.tags)) {
                        return false;
                    }
                    // Check if task has ALL selected tags (AND logic)
                    return currentTagFilters.every(selectedTag =>
                        task.tags.some(taskTag => taskTag.toLowerCase() === selectedTag.toLowerCase())
                    );
                });
            }

            if (filteredTasks.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 15px; font-size: 0.85rem; font-style: italic;">No tasks match filter</div>';
                return;
            }

            filteredTasks.forEach(taskId => {
                const taskData = tasks[taskId];
                const isCompleted = typeof taskData === 'object' ? taskData.completed : taskData;
                const priority = typeof taskData === 'object' ? taskData.priority : 'medium';
                const estimate = typeof taskData === 'object' ? taskData.estimate : 0;
                const label = typeof taskData === 'object' ? taskData.label : 'Task';
                const recurrence = typeof taskData === 'object' ? taskData.recurrence : 'none';
                const taskTags = typeof taskData === 'object' && Array.isArray(taskData.tags) ? taskData.tags : [];

                const recurrenceEmoji = {
                    'daily': '',
                    'weekly': '',
                    'monthly': '',
                    'none': ''
                }[recurrence] || '';

                const tagsHTML = `
                    <div class="task-tags-display">
                        ${taskTags.map(tag => `
                            <span class="task-tag-badge" style="
                                background: ${getTagColor(tag)}22;
                                border-color: ${getTagColor(tag)};
                                color: ${getTagColor(tag)};
                            ">
                                ${tag}
                                <button class="tag-remove-btn"
                                    onclick="removeTagFromTaskUI('${storageKey}', '${project.id}', '${taskId}', '${tag}')"
                                    title="Remove tag"></button>
                            </span>
                        `).join('')}
                        <input
                            type="text"
                            class="task-tag-input"
                            placeholder="+ tag"
                            data-storage-key="${storageKey}"
                            data-project-id="${project.id}"
                            data-task-id="${taskId}"
                        />
                    </div>
                `;

                const item = document.createElement('div');
                item.className = 'check-item';
                item.innerHTML = `
                    <div style="display: flex; gap: 8px; align-items: flex-start;">
                        <!-- Selection checkbox for bulk operations (Phase 3c) -->
                        <input type="checkbox"
                            class="task-checkbox"
                            onchange="toggleTaskSelection('${taskId}')"
                            style="margin-top: 4px; cursor: pointer;"
                            ${selectedTaskIds.has(taskId) ? 'checked' : ''}>

                        <div style="flex: 1;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <!-- Completion checkbox -->
                                <input type="checkbox" id="${taskId}" ${isCompleted ? 'checked' : ''} onchange="updateTaskInProject('${storageKey}', '${project.id}', '${taskId}')">
                                <label for="${taskId}" style="margin: 0;">${label}</label>
                            </div>
                            ${tagsHTML}
                            <div class="task-meta">
                                <span class="meta-item"><span class="priority-indicator priority-${priority}"></span>${priority.toUpperCase()}</span>
                                <span class="meta-item"> ${estimate}h</span>
                                ${recurrence !== 'none' ? `<span class="meta-item">${recurrenceEmoji} ${recurrence.toUpperCase()}</span>` : ''}
                            </div>
                        </div>
                        <div class="task-actions">
                            <button class="task-btn edit" onclick="openNotesModal('${taskId}')">NOTES</button>
                            <button class="task-btn edit" onclick="editTask('${taskId}')">EDIT</button>
                            <button class="task-btn delete" onclick="deleteTaskFromProject('${storageKey}', '${project.id}', '${taskId}'); renderDetailView(currentModule);">DELETE</button>
                        </div>
                    </div>
                `;
                container.appendChild(item);
            });

            // Set up event listeners for tag inputs
            setTimeout(() => {
                attachTagInputListeners();
            }, 50);
        }

        /**
         * Flag to track if global click listener is attached
         */
        let tagInputGlobalListenerAttached = false;

        /**
         * Attach event listeners to all tag input fields
         */
        function attachTagInputListeners() {
            const tagInputs = document.querySelectorAll('.task-tag-input');

            tagInputs.forEach(input => {
                // Remove existing listeners by cloning
                const newInput = input.cloneNode(true);
                input.parentNode.replaceChild(newInput, input);

                // Input event for autocomplete
                newInput.addEventListener('input', (e) => {
                    const inputValue = e.target.value.trim();
                    const existingTags = Array.from(e.target.parentNode.querySelectorAll('.task-tag-badge'))
                        .map(badge => {
                            // Extract tag name by removing button text
                            const text = badge.textContent.trim();
                            return text.replace(/\s*$/, '').trim();
                        });

                    if (inputValue.length > 0) {
                        const suggestions = getTagSuggestions(inputValue, existingTags);
                        showTagAutocomplete(e.target, suggestions);
                    } else {
                        hideTagAutocomplete();
                    }
                });

                // Keydown event for navigation and selection
                newInput.addEventListener('keydown', (e) => {
                    const popup = document.querySelector('.tag-autocomplete-popup');

                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const input = e.target.value.trim();

                        if (input.length === 0) {
                            return;
                        }

                        // Check if input is valid tag name
                        if (!isValidTagName(input)) {
                            console.warn('Invalid tag name');
                            return;
                        }

                        const storageKey = e.target.dataset.storageKey;
                        const projectId = e.target.dataset.projectId;
                        const taskId = e.target.dataset.taskId;

                        UndoRedoManager.saveState('Add tag');
                        if (addTagToTask(storageKey, projectId, taskId, input)) {
                            const currentModuleForKey = modules.find(m => m.storageKey === storageKey);
                            if (currentModuleForKey) {
                                renderDetailView(currentModuleForKey);
                                updateGlobalStats();
                                updateUndoRedoButtons();
                            }
                        }

                        hideTagAutocomplete();
                        e.target.value = '';
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        hideTagAutocomplete();
                    } else if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                        if (!popup) return;

                        e.preventDefault();
                        const items = popup.querySelectorAll('.tag-suggestion');
                        const currentlySelected = popup.querySelector('.tag-suggestion.selected');

                        if (e.key === 'ArrowDown') {
                            if (!currentlySelected) {
                                items[0].classList.add('selected');
                            } else {
                                const nextItem = currentlySelected.nextElementSibling;
                                if (nextItem) {
                                    currentlySelected.classList.remove('selected');
                                    nextItem.classList.add('selected');
                                    nextItem.scrollIntoView({ block: 'nearest' });
                                }
                            }
                        } else {
                            if (currentlySelected) {
                                const prevItem = currentlySelected.previousElementSibling;
                                if (prevItem) {
                                    currentlySelected.classList.remove('selected');
                                    prevItem.classList.add('selected');
                                    prevItem.scrollIntoView({ block: 'nearest' });
                                }
                            }
                        }
                    } else if (e.key === 'Tab') {
                        // Accept selected suggestion on Tab
                        if (popup) {
                            const selected = popup.querySelector('.tag-suggestion.selected');
                            if (selected) {
                                e.preventDefault();
                                const tagName = selected.querySelector('.tag-suggestion-name').textContent;
                                selectTagSuggestion(tagName, e.target);
                            }
                        }
                        hideTagAutocomplete();
                    }
                });

                // Focus event
                newInput.addEventListener('focus', (e) => {
                    const inputValue = e.target.value.trim();
                    if (inputValue.length > 0) {
                        const existingTags = Array.from(e.target.parentNode.querySelectorAll('.task-tag-badge'))
                            .map(badge => {
                                const text = badge.textContent.trim();
                                return text.replace(/\s*$/, '').trim();
                            });
                        const suggestions = getTagSuggestions(inputValue, existingTags);
                        showTagAutocomplete(e.target, suggestions);
                    }
                });

                // Blur event - hide autocomplete
                newInput.addEventListener('blur', (e) => {
                    // Delay to allow click on suggestion
                    setTimeout(() => {
                        hideTagAutocomplete();
                    }, 200);
                });
            });

            // Close autocomplete when clicking outside (only attach once globally)
            if (!tagInputGlobalListenerAttached) {
                document.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('task-tag-input') &&
                        !e.target.classList.contains('tag-suggestion') &&
                        !e.target.closest('.tag-autocomplete-popup')) {
                        hideTagAutocomplete();
                    }
                }, true);
                tagInputGlobalListenerAttached = true;
            }
        }

        function toggleProject(header) {
            const tasksContainer = header.nextElementSibling;
            const arrow = header.querySelector('span');
            tasksContainer.style.display = tasksContainer.style.display === 'none' ? 'block' : 'none';
            arrow.textContent = tasksContainer.style.display === 'none' ? '' : '';
        }

        function createNewProject() {
            if (!currentModule) return;

            const projectName = prompt('PROJECT NAME:', '').trim().toUpperCase();
            if (!projectName) return;

            if (projectName.length > 50) {
                alert('PROJECT NAME TOO LONG (MAX 50 CHARACTERS)');
                return;
            }

            const projectId = createProject(currentModule.storageKey, projectName);
            if (projectId) {
                renderDetailView(currentModule);
                renderDashboard();
                updateGlobalStats();
            }
        }

        function renameProjectUI(projectId) {
            if (!currentModule) return;

            const data = getStorageData(currentModule.storageKey);
            const project = data.projects?.[projectId];

            if (!project) return;

            // Handle user cancellation (prompt returns null if cancelled)
            const newName = prompt('NEW PROJECT NAME:', project.name);
            if (newName === null) return;

            const trimmedName = newName.trim().toUpperCase();
            if (!trimmedName || trimmedName === project.name) return;

            if (trimmedName.length > 50) {
                alert('PROJECT NAME TOO LONG (MAX 50 CHARACTERS)');
                return;
            }

            renameProject(currentModule.storageKey, projectId, trimmedName);
            renderDetailView(currentModule);
            renderDashboard();
            updateGlobalStats();
        }

        function updateTaskInProject(storageKey, projectId, taskId) {
            if (!currentModule) return;

            try {
                UndoRedoManager.saveState(`Task updated`);

                const checkbox = document.getElementById(taskId);
                const isCompleted = checkbox.checked;

                const data = getStorageData(storageKey);
                const task = data.projects?.[projectId]?.tasks?.[taskId];

                if (!task) {
                    console.error(`Task ${taskId} not found`);
                    return;
                }

                task.completed = isCompleted;

                // Handle recurring tasks
                if (isCompleted && task.recurrence && task.recurrence !== 'none') {
                    const nextDate = new Date(task.dueDate || Date.now());
                    switch(task.recurrence) {
                        case 'daily':
                            nextDate.setDate(nextDate.getDate() + 1);
                            break;
                        case 'weekly':
                            nextDate.setDate(nextDate.getDate() + 7);
                            break;
                        case 'monthly':
                            nextDate.setMonth(nextDate.getMonth() + 1);
                            break;
                    }

                    // Create new recurring task instance
                    const newTaskId = 'task_' + nextDate.getTime() + '_' + Math.random().toString(36).substr(2, 9);
                    if (!data.projects[projectId].tasks[newTaskId]) {
                        data.projects[projectId].tasks[newTaskId] = {
                            completed: false,
                            priority: task.priority,
                            estimate: task.estimate,
                            recurrence: task.recurrence,
                            label: task.label,
                            createdAt: nextDate.getTime(),
                            dueDate: nextDate.getTime()
                        };
                    }
                }

                if (setStorageData(storageKey, data)) {
                    renderDetailView(currentModule);
                    renderDashboard();
                    updateGlobalStats();
                    updateUndoRedoButtons();
                }
            } catch(error) {
                console.error('Error updating task:', error);
            }
        }

        function getTaskLabel(id, module) {
            const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
            const task = tasks[id];
            if (typeof task === 'object') {
                return task.label || 'Task';
            }
            return task || 'Task';
        }

        function setFilter(filterType) {
            currentFilter = filterType;

            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            renderDetailView(currentModule);

            // Update URL to reflect current filter
            if (currentModule) {
                updateURL({
                    module: currentModule.id,
                    filter: filterType,
                    theme: localStorage.getItem('life-os-theme') || 'dark'
                });
            }
        }

        function updateModuleProgress(changedTaskId) {
            if (!currentModule) return;

            try {
                const tasks = getStorageData(currentModule.storageKey);

                // Save state for undo/redo before making changes
                UndoRedoManager.saveState(`Task ${changedTaskId ? 'completed' : 'updated'}`);

                document.querySelectorAll('#detailChecklist input[type="checkbox"]').forEach(cb => {
                    if (tasks[cb.id]) {
                        const taskData = tasks[cb.id];
                        if (typeof taskData === 'object') {
                            taskData.completed = cb.checked;

                            // Handle recurring tasks - create next instance when checked
                            if (cb.checked && taskData.recurrence && taskData.recurrence !== 'none') {
                                const nextDate = new Date(taskData.dueDate || Date.now());
                                switch(taskData.recurrence) {
                                    case 'daily':
                                        nextDate.setDate(nextDate.getDate() + 1);
                                        break;
                                    case 'weekly':
                                        nextDate.setDate(nextDate.getDate() + 7);
                                        break;
                                    case 'monthly':
                                        nextDate.setMonth(nextDate.getMonth() + 1);
                                        break;
                                }

                                // Create new recurring task instance
                                const newId = currentModule.id + '-' + nextDate.getTime();
                                if (!tasks[newId]) {
                                    tasks[newId] = {
                                        completed: false,
                                        priority: taskData.priority,
                                        estimate: taskData.estimate,
                                        recurrence: taskData.recurrence,
                                        label: taskData.label,
                                        createdAt: nextDate.getTime(),
                                        dueDate: nextDate.getTime()
                                    };
                                }
                            }
                        } else {
                            tasks[cb.id] = cb.checked;
                        }
                    }
                });

                if (!setStorageData(currentModule.storageKey, tasks)) {
                    console.error('Failed to save task progress');
                    return;
                }

                renderDetailView(currentModule);
                renderDashboard();
                updateGlobalStats();
                updateUndoRedoButtons();
            } catch(error) {
                console.error('Error updating module progress:', error);
            }
        }

        function addDetailTask() {
            if (!currentModule) return;

            try {
                // Run migration once per session for existing data
                if (window.migrateTagsOnce !== true) {
                    migrateTasksToIncludeTags();
                    window.migrateTagsOnce = true;
                }

                const input = document.getElementById('detailInput');
                const priority = document.getElementById('prioritySelect').value;
                const recurrence = document.getElementById('recurrenceSelect').value;
                const estimate = parseFloat(document.getElementById('estimateInput').value) || 1;
                const taskLabel = input.value.trim().toUpperCase();

                // Form validation
                if (!taskLabel) {
                    alert('TASK DESCRIPTION REQUIRED');
                    return;
                }

                if (taskLabel.length > 100) {
                    alert('TASK DESCRIPTION TOO LONG (MAX 100 CHARACTERS)');
                    return;
                }

                if (estimate < 0 || estimate > 1000) {
                    alert('TIME ESTIMATE MUST BE BETWEEN 0 AND 1000 HOURS');
                    return;
                }

                // Get projects
                console.log(`Getting projects for module: ${currentModule.storageKey}`);
                const projects = getProjects(currentModule.storageKey);
                console.log(`Found ${projects.length} projects`);

                // If no projects exist, create a "General" project
                let projectId;
                if (projects.length === 0) {
                    console.log('No projects found, creating "General" project...');
                    projectId = createProject(currentModule.storageKey, 'General');
                    if (!projectId) {
                        console.error('FAILED TO CREATE DEFAULT PROJECT - check console above for details');
                        alert('FAILED TO CREATE DEFAULT PROJECT\n\nCheck browser console (F12) for detailed error info');
                        return;
                    }
                    console.log(`Created project with ID: ${projectId}`);
                } else {
                    projectId = projects[0].id;
                    console.log(`Using first project: ${projectId}`);
                }

                // Create task data with tags support
                const taskData = {
                    completed: false,
                    priority: priority,
                    estimate: estimate,
                    recurrence: recurrence,
                    label: taskLabel,
                    createdAt: Date.now(),
                    dueDate: Date.now(),
                    tags: []
                };

                // Add task to project
                console.log(`Adding task to project ${projectId}`);
                const taskId = addTaskToProject(currentModule.storageKey, projectId, taskData);
                if (!taskId) {
                    console.error('FAILED TO ADD TASK - check console above for details');
                    alert('FAILED TO CREATE TASK\n\nCheck browser console (F12) for detailed error info');
                    return;
                }
                console.log(`Task created successfully with ID: ${taskId}`);

                input.value = '';
                document.getElementById('estimateInput').value = '1';
                document.getElementById('prioritySelect').value = 'medium';
                document.getElementById('recurrenceSelect').value = 'none';
                renderDetailView(currentModule);
                renderDashboard();
                updateGlobalStats();
                updateUndoRedoButtons();
            } catch(error) {
                console.error('Error adding task:', error);
                alert('ERROR CREATING TASK // CHECK CONSOLE FOR DETAILS');
            }
        }

        function updateGlobalStats() {
            let totalTasks = 0;
            let completedTasks = 0;
            let totalHours = 0;
            let completedHours = 0;
            let highPriorityCount = 0;
            let highPriorityCompleted = 0;

            modules.forEach(module => {
                const projects = getProjects(module.storageKey);

                projects.forEach(project => {
                    const tasks = project.tasks || {};
                    const taskIds = Object.keys(tasks);

                    taskIds.forEach(id => {
                        const taskData = tasks[id];
                        if (typeof taskData === 'object') {
                            totalTasks++;
                            if (taskData.completed) completedTasks++;

                            const hours = taskData.estimate || 0;
                            totalHours += hours;
                            if (taskData.completed) completedHours += hours;

                            if (taskData.priority === 'high') {
                                highPriorityCount++;
                                if (taskData.completed) highPriorityCompleted++;
                            }
                        }
                    });
                });
            });

            const completionPercent = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
            const hoursPercent = totalHours > 0 ? Math.round((completedHours / totalHours) * 100) : 0;
            const highPriorityPercent = highPriorityCount > 0 ? Math.round((highPriorityCompleted / highPriorityCount) * 100) : 0;

            const statsGrid = document.getElementById('globalStatsGrid');
            const globalStats = document.getElementById('globalStats');

            if (totalTasks > 0) {
                globalStats.style.display = 'block';
                statsGrid.innerHTML = `
                    <div class="global-stat-box">
                        <span class="global-stat-value">${completedTasks}/${totalTasks}</span>
                        <span class="global-stat-label">TASKS COMPLETED</span>
                    </div>
                    <div class="global-stat-box">
                        <span class="global-stat-value">${completionPercent}%</span>
                        <span class="global-stat-label">COMPLETION RATE</span>
                    </div>
                    <div class="global-stat-box">
                        <span class="global-stat-value">${completedHours.toFixed(1)}h</span>
                        <span class="global-stat-label">HOURS COMPLETED</span>
                    </div>
                    <div class="global-stat-box">
                        <span class="global-stat-value">${totalHours.toFixed(1)}h</span>
                        <span class="global-stat-label">TOTAL HOURS</span>
                    </div>
                    <div class="global-stat-box">
                        <span class="global-stat-value">${highPriorityCompleted}/${highPriorityCount}</span>
                        <span class="global-stat-label">HIGH PRIORITY DONE</span>
                    </div>
                    <div class="global-stat-box">
                        <span class="global-stat-value">${hoursPercent}%</span>
                        <span class="global-stat-label">HOUR COMPLETION</span>
                    </div>
                `;
            } else {
                globalStats.style.display = 'none';
            }
        }

        function deleteTask(taskId) {
            if (!currentModule) return;

            if (!confirm('DELETE THIS TASK?')) {
                return;
            }

            try {
                const tasks = getStorageData(currentModule.storageKey);
                const taskLabel = typeof tasks[taskId] === 'object' ? tasks[taskId].label : 'Task';

                // Save state for undo/redo before making changes
                UndoRedoManager.saveState(`Task deleted: "${taskLabel}"`);

                delete tasks[taskId];

                if (!setStorageData(currentModule.storageKey, tasks)) {
                    console.error('Failed to save task deletion');
                    return;
                }

                renderDetailView(currentModule);
                renderDashboard();
                updateGlobalStats();
                updateUndoRedoButtons();
            } catch(error) {
                console.error('Error deleting task:', error);
            }
        }

        function editTask(taskId) {
            if (!currentModule) return;

            try {
                const tasks = getStorageData(currentModule.storageKey);
                const taskData = tasks[taskId];

                if (!taskData || typeof taskData !== 'object') {
                    alert('TASK NOT FOUND OR INVALID FORMAT');
                    return;
                }

                const newLabel = prompt('EDIT TASK DESCRIPTION:', taskData.label);
                if (newLabel === null) return;

                if (!newLabel.trim()) {
                    alert('TASK DESCRIPTION CANNOT BE EMPTY');
                    return;
                }

                if (newLabel.length > 100) {
                    alert('TASK DESCRIPTION TOO LONG (MAX 100 CHARACTERS)');
                    return;
                }

                const priorityOptions = 'Select priority:\n1. HIGH\n2. MEDIUM\n3. LOW\n\nEnter 1, 2, or 3:';
                const priorityInput = prompt(priorityOptions, '2');
                if (priorityInput === null) return;

                const priorityMap = { '1': 'high', '2': 'medium', '3': 'low' };
                const newPriority = priorityMap[priorityInput];

                if (!newPriority) {
                    alert('INVALID PRIORITY SELECTION');
                    return;
                }

                const estimateInput = prompt('EDIT TIME ESTIMATE (hours):', taskData.estimate);
                if (estimateInput === null) return;

                const newEstimate = parseFloat(estimateInput);
                if (isNaN(newEstimate) || newEstimate < 0 || newEstimate > 1000) {
                    alert('TIME ESTIMATE MUST BE BETWEEN 0 AND 1000 HOURS');
                    return;
                }

                const recurrenceOptions = 'Select recurrence:\n1. NONE\n2. DAILY\n3. WEEKLY\n4. MONTHLY\n\nEnter 1, 2, 3, or 4:';
                const recurrenceInput = prompt(recurrenceOptions, '1');
                if (recurrenceInput === null) return;

                const recurrenceMap = { '1': 'none', '2': 'daily', '3': 'weekly', '4': 'monthly' };
                const newRecurrence = recurrenceMap[recurrenceInput];

                if (!newRecurrence) {
                    alert('INVALID RECURRENCE SELECTION');
                    return;
                }

                // Save state for undo/redo before making changes
                UndoRedoManager.saveState(`Task edited: "${taskData.label}"`);

                taskData.label = newLabel.toUpperCase();
                taskData.priority = newPriority;
                taskData.estimate = newEstimate;
                taskData.recurrence = newRecurrence;

                tasks[taskId] = taskData;

                if (!setStorageData(currentModule.storageKey, tasks)) {
                    console.error('Failed to save task edits');
                    return;
                }

                renderDetailView(currentModule);
                renderDashboard();
                updateGlobalStats();
                updateUndoRedoButtons();
            } catch(error) {
                console.error('Error editing task:', error);
            }
        }

        function exportModuleMarkdown() {
            if (!currentModule) return;

            const tasks = JSON.parse(localStorage.getItem(currentModule.storageKey) || '{}');
            const taskIds = Object.keys(tasks);

            if (taskIds.length === 0) {
                alert('NO TASKS TO EXPORT IN THIS MODULE');
                return;
            }

            let markdown = `# ${currentModule.name}\n\n`;
            markdown += `**Module:** ${currentModule.name}\n`;
            markdown += `**Exported:** ${new Date().toLocaleString()}\n`;
            markdown += `**Total Tasks:** ${taskIds.length}\n\n`;

            const completed = taskIds.filter(id => {
                const task = tasks[id];
                return typeof task === 'object' ? task.completed : task;
            }).length;
            markdown += `**Completed:** ${completed}/${taskIds.length}\n\n`;

            markdown += '---\n\n';
            markdown += '## Tasks\n\n';

            taskIds.forEach((id, index) => {
                const taskData = tasks[id];
                const isCompleted = typeof taskData === 'object' ? taskData.completed : taskData;
                const priority = typeof taskData === 'object' ? taskData.priority : 'medium';
                const estimate = typeof taskData === 'object' ? taskData.estimate : 0;
                const label = typeof taskData === 'object' ? taskData.label : 'Task';

                const checkbox = isCompleted ? '[x]' : '[ ]';
                const priorityEmoji = priority === 'high' ? '' : priority === 'low' ? '' : '';
                const completionClass = isCompleted ? '~~' : '';

                const tags = typeof taskData === 'object' && Array.isArray(taskData.tags) ? taskData.tags : [];

                markdown += `${index + 1}. ${checkbox} ${priorityEmoji} ${completionClass}${label}${completionClass}\n`;
                markdown += `   - **Priority:** ${priority.toUpperCase()} ${priorityEmoji}\n`;
                markdown += `   - **Estimate:** ${estimate} hours\n`;
                markdown += `   - **Status:** ${isCompleted ? 'COMPLETED ' : 'PENDING '}\n`;
                if (tags.length > 0) {
                    markdown += `   - **Tags:** ${tags.join(', ')}\n`;
                }
                markdown += '\n';
            });

            markdown += '---\n\n';
            markdown += `*Generated by Life OS Command Center*\n`;
            markdown += `*https://jaydjohns.github.io/LifeOS_CommandCenter/*\n`;

            // Show modal with export content
            document.getElementById('exportTextarea').value = markdown;
            document.getElementById('exportModal').classList.add('active');
        }

        function closeExportModal() {
            document.getElementById('exportModal').classList.remove('active');
        }

        function copyExportToClipboard() {
            const textarea = document.getElementById('exportTextarea');
            textarea.select();
            document.execCommand('copy');

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' COPIED';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadExportFile() {
            const textarea = document.getElementById('exportTextarea');
            const content = textarea.value;
            const filename = `${currentModule.id}-tasks-${new Date().toISOString().split('T')[0]}.md`;

            const blob = new Blob([content], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        let currentDigestContent = '';
        let currentEditingTaskId = null;

        function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('Notifications not supported');
                return;
            }

            if (Notification.permission === 'granted') {
                return;
            }

            if (Notification.permission !== 'denied') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        new Notification('Life OS Notifications', {
                            body: 'Notifications enabled! You will receive task alerts.',
                            icon: ''
                        });
                    }
                });
            }
        }

        function sendTaskNotifications() {
            if (!('Notification' in window)) {
                alert('YOUR BROWSER DOES NOT SUPPORT NOTIFICATIONS');
                return;
            }

            if (Notification.permission === 'denied') {
                alert('NOTIFICATIONS ARE BLOCKED. PLEASE ENABLE THEM IN YOUR BROWSER SETTINGS.');
                return;
            }

            if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        sendTaskNotifications();
                    }
                });
                return;
            }

            const today = new Date();
            today.setHours(0, 0, 0, 0);

            let highPriorityTasks = [];
            let dueTodayTasks = [];
            let overdueTasks = [];
            let completionStats = { total: 0, completed: 0 };

            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                const taskIds = Object.keys(tasks);

                taskIds.forEach(id => {
                    const taskData = tasks[id];
                    if (typeof taskData === 'object') {
                        completionStats.total++;
                        if (taskData.completed) {
                            completionStats.completed++;
                        }

                        if (!taskData.completed) {
                            const taskDate = new Date(taskData.createdAt || 0);
                            taskDate.setHours(0, 0, 0, 0);

                            if (taskData.priority === 'high') {
                                highPriorityTasks.push({
                                    label: taskData.label,
                                    module: module.name,
                                    priority: 'HIGH'
                                });
                            }

                            if (taskDate.getTime() === today.getTime()) {
                                dueTodayTasks.push({
                                    label: taskData.label,
                                    module: module.name,
                                    priority: taskData.priority
                                });
                            }

                            if (taskDate < today) {
                                overdueTasks.push({
                                    label: taskData.label,
                                    module: module.name,
                                    priority: taskData.priority,
                                    daysOverdue: Math.floor((today - taskDate) / (1000 * 60 * 60 * 24))
                                });
                            }
                        }
                    }
                });
            });

            let notificationSent = false;

            if (highPriorityTasks.length > 0) {
                const count = highPriorityTasks.length;
                new Notification(' HIGH PRIORITY TASKS', {
                    body: `You have ${count} high priority task${count !== 1 ? 's' : ''} pending attention.`,
                    tag: 'high-priority',
                    requireInteraction: true
                });
                notificationSent = true;
            }

            if (overdueTasks.length > 0) {
                const count = overdueTasks.length;
                new Notification(' OVERDUE TASKS', {
                    body: `You have ${count} overdue task${count !== 1 ? 's' : ''}. Time to catch up!`,
                    tag: 'overdue',
                    requireInteraction: true
                });
                notificationSent = true;
            }

            if (dueTodayTasks.length > 0) {
                const count = dueTodayTasks.length;
                new Notification(' TODAY\'S TASKS', {
                    body: `You have ${count} task${count !== 1 ? 's' : ''} to complete today.`,
                    tag: 'today'
                });
                notificationSent = true;
            }

            if (completionStats.total > 0) {
                const completionRate = Math.round((completionStats.completed / completionStats.total) * 100);
                new Notification(' COMPLETION STATUS', {
                    body: `Overall completion: ${completionStats.completed}/${completionStats.total} (${completionRate}%)`,
                    tag: 'status'
                });
                notificationSent = true;
            }

            if (!notificationSent) {
                new Notification(' ALL CAUGHT UP!', {
                    body: 'You have no pending or overdue tasks. Great job!'
                });
            }
        }

        function generateWeeklyDigest() {
            const today = new Date();
            const weekStart = new Date(today);
            weekStart.setDate(today.getDate() - today.getDay());
            const weekEnd = new Date(weekStart);
            weekEnd.setDate(weekStart.getDate() + 6);

            let digestHTML = '';
            digestHTML += `<h3 style="color: var(--primary); margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">WEEKLY DIGEST REPORT</h3>`;
            digestHTML += `<p style="margin-bottom: 20px;"><strong>Week of:</strong> ${weekStart.toLocaleDateString()} - ${weekEnd.toLocaleDateString()}</p>`;
            digestHTML += `<p style="margin-bottom: 20px;"><strong>Generated:</strong> ${new Date().toLocaleString()}</p>`;

            let totalTasksCompleted = 0;
            let totalTasksAssigned = 0;
            let totalHoursCompleted = 0;
            let totalHoursAssigned = 0;
            let highPriorityCompleted = 0;
            let highPriorityAssigned = 0;
            let moduleBreakdown = [];

            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                const taskIds = Object.keys(tasks);

                let moduleCompleted = 0;
                let moduleAssigned = 0;
                let moduleHoursCompleted = 0;
                let moduleHoursAssigned = 0;
                let moduleHighPriority = 0;
                let moduleHighPriorityCompleted = 0;
                let taskDetails = [];

                taskIds.forEach(id => {
                    const taskData = tasks[id];
                    if (typeof taskData === 'object') {
                        const createdDate = new Date(taskData.createdAt || 0);
                        createdDate.setHours(0, 0, 0, 0);

                        const isThisWeek = createdDate >= weekStart && createdDate <= weekEnd;
                        const isCompleted = taskData.completed || false;
                        const priority = taskData.priority || 'medium';
                        const estimate = taskData.estimate || 0;

                        if (isThisWeek) {
                            moduleAssigned++;
                            totalTasksAssigned++;
                            moduleHoursAssigned += estimate;
                            totalHoursAssigned += estimate;

                            if (priority === 'high') {
                                moduleHighPriority++;
                                highPriorityAssigned++;
                            }

                            if (isCompleted) {
                                moduleCompleted++;
                                totalTasksCompleted++;
                                moduleHoursCompleted += estimate;
                                totalHoursCompleted += estimate;

                                if (priority === 'high') {
                                    moduleHighPriorityCompleted++;
                                    highPriorityCompleted++;
                                }
                            }

                            const statusEmoji = isCompleted ? '' : '';
                            const priorityEmoji = priority === 'high' ? '' : priority === 'low' ? '' : '';
                            taskDetails.push({
                                label: taskData.label,
                                priority: priority,
                                estimate: estimate,
                                completed: isCompleted,
                                statusEmoji: statusEmoji,
                                priorityEmoji: priorityEmoji
                            });
                        }
                    }
                });

                if (moduleAssigned > 0) {
                    const moduleCompletion = Math.round((moduleCompleted / moduleAssigned) * 100);
                    moduleBreakdown.push({
                        name: module.name,
                        icon: module.icon,
                        assigned: moduleAssigned,
                        completed: moduleCompleted,
                        completion: moduleCompletion,
                        hoursAssigned: moduleHoursAssigned,
                        hoursCompleted: moduleHoursCompleted,
                        highPriority: moduleHighPriority,
                        highPriorityCompleted: moduleHighPriorityCompleted,
                        tasks: taskDetails
                    });
                }
            });

            // Summary Stats
            digestHTML += `<h3 style="color: var(--primary); margin-top: 30px; margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">WEEKLY SUMMARY</h3>`;
            digestHTML += `<table style="width: 100%; margin-bottom: 20px; border-collapse: collapse;">`;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Total Tasks Assigned:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--primary);">${totalTasksAssigned}</td>`;
            digestHTML += `</tr>`;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Tasks Completed:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--success);">${totalTasksCompleted}</td>`;
            digestHTML += `</tr>`;
            const taskCompletion = totalTasksAssigned > 0 ? Math.round((totalTasksCompleted / totalTasksAssigned) * 100) : 0;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Completion Rate:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--primary);">${taskCompletion}%</td>`;
            digestHTML += `</tr>`;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Hours Assigned:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--primary);">${totalHoursAssigned.toFixed(1)}h</td>`;
            digestHTML += `</tr>`;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Hours Completed:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--success);">${totalHoursCompleted.toFixed(1)}h</td>`;
            digestHTML += `</tr>`;
            const hourCompletion = totalHoursAssigned > 0 ? Math.round((totalHoursCompleted / totalHoursAssigned) * 100) : 0;
            digestHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>Hour Completion Rate:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--primary);">${hourCompletion}%</td>`;
            digestHTML += `</tr>`;
            digestHTML += `<tr>`;
            digestHTML += `<td style="padding: 10px; text-align: left;"><strong>High Priority Tasks:</strong></td>`;
            digestHTML += `<td style="padding: 10px; text-align: right; color: var(--accent);">${highPriorityCompleted}/${highPriorityAssigned}</td>`;
            digestHTML += `</tr>`;
            digestHTML += `</table>`;

            // Module Breakdown
            if (moduleBreakdown.length > 0) {
                digestHTML += `<h3 style="color: var(--primary); margin-top: 30px; margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">MODULE BREAKDOWN</h3>`;

                moduleBreakdown.forEach(mod => {
                    digestHTML += `<div style="background: rgba(0, 99, 255, 0.1); padding: 15px; margin-bottom: 15px; border-radius: 4px; border-left: 4px solid var(--primary);">`;
                    digestHTML += `<h4 style="color: var(--primary); margin-bottom: 10px;">${mod.icon} ${mod.name}</h4>`;
                    digestHTML += `<table style="width: 100%; font-size: 0.85rem;">`;
                    digestHTML += `<tr><td style="padding: 5px;">Tasks:</td><td style="text-align: right;">${mod.completed}/${mod.assigned}</td></tr>`;
                    digestHTML += `<tr><td style="padding: 5px;">Completion:</td><td style="text-align: right; color: var(--primary);">${mod.completion}%</td></tr>`;
                    digestHTML += `<tr><td style="padding: 5px;">Hours:</td><td style="text-align: right;">${mod.hoursCompleted.toFixed(1)}/${mod.hoursAssigned.toFixed(1)}h</td></tr>`;
                    if (mod.highPriority > 0) {
                        digestHTML += `<tr><td style="padding: 5px; color: var(--accent);">High Priority:</td><td style="text-align: right; color: var(--accent);">${mod.highPriorityCompleted}/${mod.highPriority}</td></tr>`;
                    }
                    digestHTML += `</table>`;
                    digestHTML += `</div>`;
                });
            }

            digestHTML += `<hr style="border: none; border-top: 1px solid rgba(0, 212, 255, 0.2); margin: 30px 0;">`;
            digestHTML += `<p style="font-size: 0.85rem; color: var(--text-secondary); text-align: center;">Generated by Life OS Command Center</p>`;

            currentDigestContent = digestHTML;
            document.getElementById('digestContent').innerHTML = digestHTML;
            document.getElementById('digestModal').classList.add('active');
        }

        function closeDigestModal() {
            document.getElementById('digestModal').classList.remove('active');
        }

        function copyDigestToClipboard() {
            const text = document.getElementById('digestContent').innerText;
            const blob = new Blob([text], { type: 'text/plain' });
            const tempDiv = document.createElement('textarea');
            tempDiv.value = text;
            document.body.appendChild(tempDiv);
            tempDiv.select();
            document.execCommand('copy');
            document.body.removeChild(tempDiv);

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' COPIED';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadDigestReport() {
            const text = document.getElementById('digestContent').innerText;
            const filename = `life-os-weekly-digest-${new Date().toISOString().split('T')[0]}.txt`;

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function openNotesModal(taskId) {
            if (!currentModule) return;

            const tasks = JSON.parse(localStorage.getItem(currentModule.storageKey) || '{}');
            const taskData = tasks[taskId];

            if (!taskData || typeof taskData !== 'object') {
                alert('TASK NOT FOUND');
                return;
            }

            currentEditingTaskId = taskId;
            const label = taskData.label || 'Task';

            document.getElementById('notesTaskTitle').textContent = label;
            document.getElementById('notesText').value = taskData.notes || '';

            // Render subtasks
            const subtasksList = document.getElementById('subtasksList');
            subtasksList.innerHTML = '';

            const subtasks = taskData.subtasks || [];
            if (subtasks.length === 0) {
                subtasksList.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 20px; font-style: italic;">NO SUBTASKS YET</div>';
            } else {
                subtasks.forEach((subtask, index) => {
                    const completed = subtask.completed || false;
                    const subtaskDiv = document.createElement('div');
                    subtaskDiv.className = 'subtask-item';
                    subtaskDiv.innerHTML = `
                        <input type="checkbox" id="st-${index}" ${completed ? 'checked' : ''} onchange="toggleSubtask(${index})">
                        <label for="st-${index}">${subtask.label}</label>
                        <button class="subtask-delete" onclick="deleteSubtask(${index})"></button>
                    `;
                    subtasksList.appendChild(subtaskDiv);
                });
            }

            document.getElementById('notesModal').classList.add('active');
            document.getElementById('subtaskInput').value = '';

            // Initialize tag UI
            setTimeout(() => {
                renderModalTags();
                setupTagInputListeners();
                const tagInput = document.getElementById('tagInput');
                if (tagInput) tagInput.focus();
            }, 50);
        }

        function closeNotesModal() {
            document.getElementById('notesModal').classList.remove('active');
            currentEditingTaskId = null;
        }

        function addSubtask() {
            try {
                const input = document.getElementById('subtaskInput');
                const label = input.value.trim();

                if (!label) {
                    alert('SUBTASK DESCRIPTION REQUIRED');
                    return;
                }

                if (label.length > 100) {
                    alert('SUBTASK TOO LONG (MAX 100 CHARACTERS)');
                    return;
                }

                const tasks = getStorageData(currentModule.storageKey);
                const taskData = tasks[currentEditingTaskId];

                // Save state for undo/redo before making changes
                UndoRedoManager.saveState(`Subtask added: "${label}"`);

                if (!taskData.subtasks) {
                    taskData.subtasks = [];
                }

                taskData.subtasks.push({
                    label: label.toUpperCase(),
                    completed: false
                });

                tasks[currentEditingTaskId] = taskData;

                if (!setStorageData(currentModule.storageKey, tasks)) {
                    console.error('Failed to save subtask');
                    return;
                }

                input.value = '';
                updateUndoRedoButtons();
                openNotesModal(currentEditingTaskId);
            } catch(error) {
                console.error('Error adding subtask:', error);
            }
        }

        function deleteSubtask(index) {
            try {
                const tasks = getStorageData(currentModule.storageKey);
                const taskData = tasks[currentEditingTaskId];

                if (taskData.subtasks) {
                    // Save state for undo/redo before making changes
                    UndoRedoManager.saveState(`Subtask deleted`);

                    taskData.subtasks.splice(index, 1);
                    tasks[currentEditingTaskId] = taskData;

                    if (!setStorageData(currentModule.storageKey, tasks)) {
                        console.error('Failed to save subtask deletion');
                        return;
                    }

                    updateUndoRedoButtons();
                    openNotesModal(currentEditingTaskId);
                }
            } catch(error) {
                console.error('Error deleting subtask:', error);
            }
        }

        function toggleSubtask(index) {
            try {
                const checkbox = document.getElementById(`st-${index}`);
                const tasks = getStorageData(currentModule.storageKey);
                const taskData = tasks[currentEditingTaskId];

                if (taskData.subtasks && taskData.subtasks[index]) {
                    // Save state for undo/redo before making changes
                    UndoRedoManager.saveState(`Subtask toggled`);

                    taskData.subtasks[index].completed = checkbox.checked;
                    tasks[currentEditingTaskId] = taskData;

                    if (!setStorageData(currentModule.storageKey, tasks)) {
                        console.error('Failed to save subtask toggle');
                        return;
                    }

                    updateUndoRedoButtons();
                }
            } catch(error) {
                console.error('Error toggling subtask:', error);
            }
        }

        function saveTaskDetails() {
            if (!currentEditingTaskId) return;

            try {
                const tasks = getStorageData(currentModule.storageKey);
                const taskData = tasks[currentEditingTaskId];

                if (taskData && typeof taskData === 'object') {
                    // Save state for undo/redo before making changes
                    UndoRedoManager.saveState(`Task notes updated`);

                    taskData.notes = document.getElementById('notesText').value;
                    tasks[currentEditingTaskId] = taskData;

                    if (!setStorageData(currentModule.storageKey, tasks)) {
                        console.error('Failed to save task details');
                        return;
                    }

                    closeNotesModal();
                    renderDetailView(currentModule);
                    updateGlobalStats();
                    updateUndoRedoButtons();
                }
            } catch(error) {
                console.error('Error saving task details:', error);
            }
        }

        /**
         * Open tag suggestions dropdown as user types
         */
        function updateTagSuggestions() {
            const input = document.getElementById('tagInput');
            const suggestionsDiv = document.getElementById('tagSuggestions');
            const tagValue = input.value.trim().toLowerCase();

            if (!tagValue) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            const allTags = getAllTags();
            const currentTags = getCurrentTaskTags();

            // Filter suggestions: match input, not already on task, limit to 5
            const suggestions = allTags
                .filter(t => t.name.includes(tagValue) && !currentTags.includes(t.name))
                .slice(0, 5);

            if (suggestions.length === 0 && isValidTagName(tagValue)) {
                // Show "create new" option
                suggestionsDiv.innerHTML = `
                    <div style="padding: 4px 8px; cursor: pointer; color: var(--primary);" onclick="createAndAddTag('${tagValue}')">
                        + Create: <strong>${tagValue}</strong>
                    </div>
                `;
                suggestionsDiv.style.display = 'block';
                return;
            }

            if (suggestions.length > 0) {
                suggestionsDiv.innerHTML = suggestions
                    .map(tag => `
                        <div style="padding: 4px 8px; cursor: pointer; color: var(--text-primary); border-radius: 3px;"
                             onmouseover="this.style.background='rgba(0, 212, 255, 0.1)'"
                             onmouseout="this.style.background='transparent'"
                             onclick="addSelectedTag('${tag.name}')">
                            ${tag.name} <span style="font-size: 0.8rem; color: var(--text-secondary);">(${getTagUsageCount(tag.name)})</span>
                        </div>
                    `)
                    .join('');
                suggestionsDiv.style.display = 'block';
            } else {
                suggestionsDiv.style.display = 'none';
            }
        }

        /**
         * Get tags for currently editing task
         */
        function getCurrentTaskTags() {
            if (!currentEditingTaskId || !currentModule) return [];

            const data = getStorageData(currentModule.storageKey);
            if (!data) return [];

            // Find task across all projects
            for (const project of Object.values(data.projects || {})) {
                const task = project.tasks?.[currentEditingTaskId];
                if (task) {
                    return task.tags || [];
                }
            }

            return [];
        }

        /**
         * Render tags in the modal
         */
        function renderModalTags() {
            if (!currentEditingTaskId || !currentModule) return;

            const currentTags = getCurrentTaskTags();
            const tagsList = document.getElementById('currentTagsList');

            if (!tagsList) return;

            tagsList.innerHTML = currentTags
                .map(tag => `
                    <div style="
                        display: inline-flex;
                        align-items: center;
                        gap: 6px;
                        padding: 4px 10px;
                        background: ${getTagColor(tag)}22;
                        border: 1px solid ${getTagColor(tag)};
                        border-radius: 20px;
                        color: var(--text-primary);
                        font-size: 0.85rem;
                    ">
                        ${tag}
                        <span style="cursor: pointer; font-weight: bold;" onclick="removeTagFromModal('${tag}')"></span>
                    </div>
                `)
                .join('');
        }

        /**
         * Add tag from modal input
         */
        function addTagFromModal() {
            const input = document.getElementById('tagInput');
            const tagValue = input.value.trim().toLowerCase();

            if (!tagValue) {
                alert('Enter a tag name');
                return;
            }

            if (!isValidTagName(tagValue)) {
                alert('Invalid tag name (max 25 chars, alphanumeric/dash/underscore only)');
                return;
            }

            addSelectedTag(tagValue);
            input.value = '';
            document.getElementById('tagSuggestions').style.display = 'none';
        }

        /**
         * Add an existing or new tag to task
         */
        function addSelectedTag(tagName) {
            if (!currentEditingTaskId || !currentModule) return;

            const currentTags = getCurrentTaskTags();

            // Check max tags
            if (currentTags.length >= 3) {
                alert('Maximum 3 tags per task');
                return;
            }

            // Check duplicate
            if (currentTags.some(t => t.toLowerCase() === tagName.toLowerCase())) {
                alert('Tag already on this task');
                return;
            }

            // Find project ID
            const data = getStorageData(currentModule.storageKey);
            let projectId = null;
            for (const [pId, project] of Object.entries(data.projects || {})) {
                if (project.tasks?.[currentEditingTaskId]) {
                    projectId = pId;
                    break;
                }
            }

            if (!projectId) {
                console.error('Could not find project for task');
                return;
            }

            // Save undo state
            UndoRedoManager.saveState(`Add tag "${tagName}" to task`);

            // Add tag
            if (addTagToTask(currentModule.storageKey, projectId, currentEditingTaskId, tagName)) {
                renderModalTags();
                document.getElementById('tagInput').value = '';
                document.getElementById('tagSuggestions').style.display = 'none';
                updateUndoRedoButtons();

                // Refresh task display
                renderDetailView(currentModule);
            } else {
                alert('Failed to add tag');
            }
        }

        /**
         * Remove tag from task in modal
         */
        function removeTagFromModal(tagName) {
            if (!currentEditingTaskId || !currentModule) {
                console.error('No task being edited');
                return;
            }

            // Find project ID
            const data = getStorageData(currentModule.storageKey);
            let projectId = null;
            for (const [pId, project] of Object.entries(data.projects || {})) {
                if (project.tasks?.[currentEditingTaskId]) {
                    projectId = pId;
                    break;
                }
            }

            if (!projectId) {
                console.error('Could not find project for task');
                return;
            }

            // Save undo state
            UndoRedoManager.saveState(`Remove tag "${tagName}" from task`);

            // Remove tag
            if (removeTagFromTask(currentModule.storageKey, projectId, currentEditingTaskId, tagName)) {
                renderModalTags();
                updateUndoRedoButtons();

                // Refresh task display
                renderDetailView(currentModule);
            } else {
                alert('Failed to remove tag');
            }
        }

        /**
         * Create and add a new tag
         */
        function createAndAddTag(tagName) {
            if (!isValidTagName(tagName)) {
                alert('Invalid tag name');
                return;
            }

            if (createTag(tagName)) {
                addSelectedTag(tagName);
            } else {
                alert('Failed to create tag');
            }
        }

        /**
         * Set up tag input event listeners in modal
         */
        function setupTagInputListeners() {
            const tagInput = document.getElementById('tagInput');
            if (!tagInput) return;

            tagInput.addEventListener('input', () => {
                updateTagSuggestions();
            });

            tagInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    addTagFromModal();
                }
            });
        }

        function toggleTheme() {
            const body = document.body;
            body.classList.toggle('light-theme');

            // Save theme preference
            const theme = body.classList.contains('light-theme') ? 'light' : 'dark';
            localStorage.setItem('life-os-theme', theme);

            // Update button text and ARIA state
            const themeBtn = document.querySelector('.theme-toggle');
            themeBtn.textContent = theme === 'light' ? ' DARK' : ' LIGHT';
            themeBtn.setAttribute('aria-pressed', theme === 'light' ? 'true' : 'false');

            // Update URL to reflect theme change
            const params = getURLParameters();
            updateURL({
                ...params,
                theme: theme
            });
        }

        function openHeatmapModal() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Calculate 90 days of activity
            const activityData = {};
            for (let i = 89; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateKey = date.toISOString().split('T')[0];
                activityData[dateKey] = { completed: 0, total: 0, percentage: 0 };
            }

            // Scan all modules and tasks
            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                Object.values(tasks).forEach(taskData => {
                    if (typeof taskData === 'object' && taskData.createdAt) {
                        const taskDate = new Date(taskData.createdAt);
                        taskDate.setHours(0, 0, 0, 0);
                        const dateKey = taskDate.toISOString().split('T')[0];

                        if (activityData[dateKey]) {
                            activityData[dateKey].total++;
                            if (taskData.completed) {
                                activityData[dateKey].completed++;
                            }
                        }
                    }
                });
            });

            // Calculate completion percentages and activity levels
            const activityLevels = {};
            Object.entries(activityData).forEach(([date, data]) => {
                if (data.total > 0) {
                    data.percentage = Math.round((data.completed / data.total) * 100);
                } else {
                    data.percentage = 0;
                }

                // Assign activity level (0-4)
                if (data.total === 0) {
                    activityLevels[date] = 0;
                } else if (data.percentage < 25) {
                    activityLevels[date] = 1;
                } else if (data.percentage < 50) {
                    activityLevels[date] = 2;
                } else if (data.percentage < 75) {
                    activityLevels[date] = 3;
                } else {
                    activityLevels[date] = 4;
                }
            });

            // Generate heatmap HTML
            let heatmapHTML = '<div class="heatmap-grid">';

            // Get 90-day range
            let currentDate = new Date(today);
            currentDate.setDate(currentDate.getDate() - 89);

            for (let i = 0; i < 90; i++) {
                const dateKey = currentDate.toISOString().split('T')[0];
                const dayOfWeek = currentDate.toLocaleDateString('en-US', { weekday: 'short' });
                const dayNum = currentDate.getDate();
                const activity = activityLevels[dateKey] || 0;
                const activityData_day = activityData[dateKey];

                const tooltip = activityData_day.total > 0
                    ? `${activityData_day.completed}/${activityData_day.total} (${activityData_day.percentage}%)`
                    : 'No tasks';

                heatmapHTML += `<div class="heatmap-cell activity-${activity}" title="${dateKey}: ${tooltip}">${dayNum}</div>`;
                currentDate.setDate(currentDate.getDate() + 1);
            }

            heatmapHTML += '</div>';

            // Add legend
            heatmapHTML += `<div class="heatmap-legend" style="display: flex; gap: 20px; margin-top: 20px; flex-wrap: wrap; justify-content: center;">`;
            heatmapHTML += `<div style="display: flex; align-items: center; gap: 8px;"><div class="heatmap-cell activity-0" style="width: 30px; height: 30px;"></div><span>No Activity</span></div>`;
            heatmapHTML += `<div style="display: flex; align-items: center; gap: 8px;"><div class="heatmap-cell activity-1" style="width: 30px; height: 30px;"></div><span>Low (1-25%)</span></div>`;
            heatmapHTML += `<div style="display: flex; align-items: center; gap: 8px;"><div class="heatmap-cell activity-2" style="width: 30px; height: 30px;"></div><span>Medium (26-50%)</span></div>`;
            heatmapHTML += `<div style="display: flex; align-items: center; gap: 8px;"><div class="heatmap-cell activity-3" style="width: 30px; height: 30px;"></div><span>High (51-75%)</span></div>`;
            heatmapHTML += `<div style="display: flex; align-items: center; gap: 8px;"><div class="heatmap-cell activity-4" style="width: 30px; height: 30px;"></div><span>Very High (76-100%)</span></div>`;
            heatmapHTML += `</div>`;

            heatmapHTML += `<p style="margin-top: 20px; font-size: 0.85rem; color: var(--text-secondary); text-align: center;">Last 90 days of activity - hover over cells to see details</p>`;

            document.getElementById('heatmapContent').innerHTML = heatmapHTML;
            document.getElementById('heatmapModal').classList.add('active');
            document.getElementById('heatmapBtn').setAttribute('aria-expanded', 'true');
        }

        function closeHeatmapModal() {
            document.getElementById('heatmapModal').classList.remove('active');
            document.getElementById('heatmapBtn').setAttribute('aria-expanded', 'false');
        }

        function openAnalyticsModal() {
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Calculate 30-day window
            const thirtyDaysAgo = new Date(today);
            thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);

            let analyticsHTML = '';
            analyticsHTML += `<h3 style="color: var(--primary); margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">PERFORMANCE ANALYTICS DASHBOARD</h3>`;
            analyticsHTML += `<p style="margin-bottom: 20px;"><strong>Generated:</strong> ${new Date().toLocaleString()}</p>`;

            // Collect data
            let allTasks = [];
            let moduleStats = [];
            let totalTasksCompleted = 0;
            let totalTasksCreated = 0;
            let totalHoursCompleted = 0;
            let totalHoursEstimated = 0;
            let highPriorityCompleted = 0;
            let highPriorityTotal = 0;

            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                let moduleCompleted = 0;
                let moduleCreated = 0;
                let moduleHoursCompleted = 0;
                let moduleHoursEstimated = 0;
                let moduleHighPriority = 0;
                let moduleHighPriorityCompleted = 0;

                Object.entries(tasks).forEach(([id, taskData]) => {
                    if (typeof taskData === 'object') {
                        const createdDate = new Date(taskData.createdAt || 0);
                        createdDate.setHours(0, 0, 0, 0);
                        const isThisMonth = createdDate >= thirtyDaysAgo && createdDate <= today;

                        if (isThisMonth) {
                            moduleCreated++;
                            totalTasksCreated++;
                            const estimate = taskData.estimate || 0;
                            moduleHoursEstimated += estimate;
                            totalHoursEstimated += estimate;

                            if (taskData.completed) {
                                moduleCompleted++;
                                totalTasksCompleted++;
                                moduleHoursCompleted += estimate;
                                totalHoursCompleted += estimate;
                            }

                            if (taskData.priority === 'high') {
                                moduleHighPriority++;
                                highPriorityTotal++;
                                if (taskData.completed) {
                                    moduleHighPriorityCompleted++;
                                    highPriorityCompleted++;
                                }
                            }

                            allTasks.push({
                                module: module.name,
                                icon: module.icon,
                                label: taskData.label,
                                completed: taskData.completed,
                                priority: taskData.priority || 'medium',
                                estimate: estimate,
                                createdDate: createdDate
                            });
                        }
                    }
                });

                if (moduleCreated > 0) {
                    moduleStats.push({
                        name: module.name,
                        icon: module.icon,
                        created: moduleCreated,
                        completed: moduleCompleted,
                        hoursEstimated: moduleHoursEstimated,
                        hoursCompleted: moduleHoursCompleted,
                        highPriority: moduleHighPriority,
                        highPriorityCompleted: moduleHighPriorityCompleted
                    });
                }
            });

            // Overall Summary
            analyticsHTML += `<h3 style="color: var(--primary); margin-top: 25px; margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">OVERALL SUMMARY (Last 30 Days)</h3>`;
            analyticsHTML += `<table style="width: 100%; margin-bottom: 20px; border-collapse: collapse;">`;

            const taskCompletionRate = totalTasksCreated > 0 ? Math.round((totalTasksCompleted / totalTasksCreated) * 100) : 0;
            const hourCompletionRate = totalHoursEstimated > 0 ? Math.round((totalHoursCompleted / totalHoursEstimated) * 100) : 0;
            const highPriorityRate = highPriorityTotal > 0 ? Math.round((highPriorityCompleted / highPriorityTotal) * 100) : 0;
            const avgTasksPerDay = totalTasksCreated > 0 ? (totalTasksCreated / 30).toFixed(1) : 0;
            const avgHoursPerDay = totalHoursEstimated > 0 ? (totalHoursEstimated / 30).toFixed(1) : 0;

            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Tasks Created:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: var(--primary);">${totalTasksCreated}</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Tasks Completed:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: var(--success);">${totalTasksCompleted}</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Completion Rate:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: ${taskCompletionRate >= 75 ? 'var(--success)' : taskCompletionRate >= 50 ? 'var(--warning)' : 'var(--accent)'};">${taskCompletionRate}%</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Hours Estimated:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right;">${totalHoursEstimated.toFixed(1)}h</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Hours Completed:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: var(--success);">${totalHoursCompleted.toFixed(1)}h</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Hour Completion Rate:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: ${hourCompletionRate >= 75 ? 'var(--success)' : hourCompletionRate >= 50 ? 'var(--warning)' : 'var(--accent)'};">${hourCompletionRate}%</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>High Priority (Completed/Total):</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right; color: var(--accent);">${highPriorityCompleted}/${highPriorityTotal} (${highPriorityRate}%)</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr style="border-bottom: 1px solid rgba(0, 212, 255, 0.2);">`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Avg Tasks/Day:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right;">${avgTasksPerDay}</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `<tr>`;
            analyticsHTML += `<td style="padding: 10px;"><strong>Avg Hours/Day:</strong></td>`;
            analyticsHTML += `<td style="padding: 10px; text-align: right;">${avgHoursPerDay}h</td>`;
            analyticsHTML += `</tr>`;
            analyticsHTML += `</table>`;

            // Module Performance
            if (moduleStats.length > 0) {
                analyticsHTML += `<h3 style="color: var(--primary); margin-top: 25px; margin-bottom: 15px; border-bottom: 2px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;">MODULE PERFORMANCE</h3>`;

                // Sort by completion rate
                moduleStats.sort((a, b) => {
                    const rateA = a.created > 0 ? (a.completed / a.created) : 0;
                    const rateB = b.created > 0 ? (b.completed / b.created) : 0;
                    return rateB - rateA;
                });

                moduleStats.forEach(mod => {
                    const rate = mod.created > 0 ? Math.round((mod.completed / mod.created) * 100) : 0;
                    analyticsHTML += `<div style="background: rgba(0, 99, 255, 0.1); padding: 12px; margin-bottom: 12px; border-radius: 4px; border-left: 4px solid ${rate >= 75 ? 'var(--success)' : rate >= 50 ? 'var(--warning)' : 'var(--accent)'};">`;
                    analyticsHTML += `<h4 style="color: var(--primary); margin-bottom: 8px;">${mod.icon} ${mod.name}</h4>`;
                    analyticsHTML += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.8rem;">`;
                    analyticsHTML += `<div><strong>Completion:</strong> ${mod.completed}/${mod.created} (${rate}%)</div>`;
                    analyticsHTML += `<div><strong>Hours:</strong> ${mod.hoursCompleted.toFixed(1)}/${mod.hoursEstimated.toFixed(1)}h</div>`;
                    if (mod.highPriority > 0) {
                        const highRate = Math.round((mod.highPriorityCompleted / mod.highPriority) * 100);
                        analyticsHTML += `<div style="color: var(--accent);"><strong>High Priority:</strong> ${mod.highPriorityCompleted}/${mod.highPriority} (${highRate}%)</div>`;
                    }
                    analyticsHTML += `</div>`;
                    analyticsHTML += `</div>`;
                });

                // Best and Worst
                const bestModule = moduleStats[0];
                const worstModule = moduleStats[moduleStats.length - 1];
                analyticsHTML += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">`;
                analyticsHTML += `<div style="background: rgba(0, 255, 136, 0.15); padding: 12px; border-radius: 4px; border: 1px solid var(--success);">`;
                analyticsHTML += `<strong style="color: var(--success);"> Best Performer</strong><br>`;
                analyticsHTML += `${bestModule.icon} ${bestModule.name}<br>`;
                const bestRate = bestModule.created > 0 ? Math.round((bestModule.completed / bestModule.created) * 100) : 0;
                analyticsHTML += `<small style="color: var(--text-secondary);">${bestRate}% completion rate</small>`;
                analyticsHTML += `</div>`;
                analyticsHTML += `<div style="background: rgba(255, 0, 110, 0.15); padding: 12px; border-radius: 4px; border: 1px solid var(--accent);">`;
                analyticsHTML += `<strong style="color: var(--accent);"> Needs Attention</strong><br>`;
                analyticsHTML += `${worstModule.icon} ${worstModule.name}<br>`;
                const worstRate = worstModule.created > 0 ? Math.round((worstModule.completed / worstModule.created) * 100) : 0;
                analyticsHTML += `<small style="color: var(--text-secondary);">${worstRate}% completion rate</small>`;
                analyticsHTML += `</div>`;
                analyticsHTML += `</div>`;
            }

            analyticsHTML += `<hr style="border: none; border-top: 1px solid rgba(0, 212, 255, 0.2); margin: 25px 0;">`;
            analyticsHTML += `<p style="font-size: 0.75rem; color: var(--text-secondary); text-align: center;">Performance data calculated from tasks created in the last 30 days</p>`;

            document.getElementById('analyticsContent').innerHTML = analyticsHTML;
            document.getElementById('analyticsModal').classList.add('active');
            document.getElementById('analyticsBtn').setAttribute('aria-expanded', 'true');
        }

        function closeAnalyticsModal() {
            document.getElementById('analyticsModal').classList.remove('active');
            document.getElementById('analyticsBtn').setAttribute('aria-expanded', 'false');
        }

        function copyAnalyticsToClipboard() {
            const text = document.getElementById('analyticsContent').innerText;
            const tempDiv = document.createElement('textarea');
            tempDiv.value = text;
            document.body.appendChild(tempDiv);
            tempDiv.select();
            document.execCommand('copy');
            document.body.removeChild(tempDiv);

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' COPIED';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function downloadAnalyticsReport() {
            const text = document.getElementById('analyticsContent').innerText;
            const filename = `life-os-analytics-${new Date().toISOString().split('T')[0]}.txt`;

            const blob = new Blob([text], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Sync Modal Functions
        function openSyncModal() {
            document.getElementById('syncModal').classList.add('active');
            document.getElementById('syncBtn').setAttribute('aria-expanded', 'true');
        }

        function closeSyncModal() {
            document.getElementById('syncModal').classList.remove('active');
            document.getElementById('syncBtn').setAttribute('aria-expanded', 'false');
        }

        function showSyncTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.sync-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Remove active state from all buttons
            document.querySelectorAll('.sync-tab-btn').forEach(btn => {
                btn.style.background = 'transparent';
                btn.style.color = 'var(--text-secondary)';
            });

            // Show selected tab
            const selectedTab = document.getElementById(`syncTab-${tabName}`);
            if (selectedTab) {
                selectedTab.style.display = 'block';
            }

            // Set active button
            const activeBtn = document.getElementById(`tab-${tabName}`);
            if (activeBtn) {
                activeBtn.style.background = 'rgba(0, 212, 255, 0.2)';
                activeBtn.style.color = 'var(--primary)';
            }
        }

        // Help Modal Functions
        function openHelpModal() {
            document.getElementById('helpModal').classList.add('active');
            document.getElementById('helpBtn').setAttribute('aria-expanded', 'true');
            // Show quick start tab by default
            showHelpTab('quickstart');
        }

        function closeHelpModal() {
            document.getElementById('helpModal').classList.remove('active');
            document.getElementById('helpBtn').setAttribute('aria-expanded', 'false');
        }

        function showHelpTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.help-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Remove active state from all buttons
            document.querySelectorAll('.help-tab-btn').forEach(btn => {
                btn.style.background = 'transparent';
                btn.style.color = 'var(--text-secondary)';
            });

            // Show selected tab
            const selectedTab = document.getElementById(`help-${tabName}`);
            if (selectedTab) {
                selectedTab.style.display = 'block';
            }

            // Set active button
            const activeBtn = document.getElementById(`help-tab-${tabName}`);
            if (activeBtn) {
                activeBtn.style.background = 'rgba(0, 212, 255, 0.2)';
                activeBtn.style.color = 'var(--primary)';
            }
        }

        function showOnboardingBanner() {
            const hasSeenOnboarding = localStorage.getItem('life-os-onboarding-shown');
            if (!hasSeenOnboarding) {
                const banner = document.getElementById('onboardingBanner');
                if (banner) {
                    banner.style.display = 'block';
                    // Add animation
                    banner.classList.add('slideDown');
                }
            }
        }

        function dismissOnboardingBanner() {
            const banner = document.getElementById('onboardingBanner');
            if (banner) {
                banner.style.display = 'none';
            }
            // Mark as seen
            localStorage.setItem('life-os-onboarding-shown', 'true');
        }

        // Export Functions
        function exportDataAsJSON() {
            const allData = {};

            // Collect all module data
            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                allData[module.storageKey] = tasks;
            });

            // Add tag registry
            const tagRegistry = JSON.parse(localStorage.getItem('life-os-tags-registry') || '{"tags":[]}');
            allData['life-os-tags-registry'] = tagRegistry;

            // Add theme preference
            allData['life-os-theme'] = localStorage.getItem('life-os-theme') || 'dark';
            allData['export-date'] = new Date().toISOString();
            allData['export-version'] = '2.1';

            // Create download
            const filename = `life-os-backup-${new Date().toISOString().split('T')[0]}.json`;
            const blob = new Blob([JSON.stringify(allData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Show confirmation
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' EXPORTED';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        function copyDataToClipboard() {
            const allData = {};

            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                allData[module.storageKey] = tasks;
            });

            allData['life-os-theme'] = localStorage.getItem('life-os-theme') || 'dark';
            allData['export-date'] = new Date().toISOString();

            const jsonString = JSON.stringify(allData, null, 2);
            const tempDiv = document.createElement('textarea');
            tempDiv.value = jsonString;
            document.body.appendChild(tempDiv);
            tempDiv.select();
            document.execCommand('copy');
            document.body.removeChild(tempDiv);

            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = ' COPIED';
            setTimeout(() => {
                btn.textContent = originalText;
            }, 2000);
        }

        // Import Functions
        function importDataFromJSON() {
            try {
                const jsonString = document.getElementById('importJSON').value.trim();

                if (!jsonString) {
                    alert(' Please paste JSON data first');
                    return;
                }

                const importedData = JSON.parse(jsonString);

                // Import module data
                let importedCount = 0;
                modules.forEach(module => {
                    if (importedData[module.storageKey]) {
                        localStorage.setItem(module.storageKey, JSON.stringify(importedData[module.storageKey]));
                        importedCount++;
                    }
                });

                // Import theme if present
                if (importedData['life-os-theme']) {
                    localStorage.setItem('life-os-theme', importedData['life-os-theme']);
                }

                alert(` Successfully imported ${importedCount} modules!`);

                // Refresh the app
                location.reload();
            } catch (error) {
                alert(` Error importing data: ${error.message}`);
            }
        }

        function clearImportField() {
            document.getElementById('importJSON').value = '';
        }

        // GitHub Integration Functions
        function validateGitHubCredentials() {
            const token = document.getElementById('githubToken').value.trim();
            const repo = document.getElementById('githubRepo').value.trim();

            if (!token || !repo) {
                alert(' Please enter both GitHub token and repository');
                return;
            }

            const [owner, repoName] = repo.split('/');

            if (!owner || !repoName) {
                alert(' Repository format should be: username/repository');
                return;
            }

            // Test the connection
            fetch(`https://api.github.com/repos/${owner}/${repoName}`, {
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            })
            .then(response => {
                if (response.status === 200) {
                    alert(' Connection successful! Repository access verified.');
                } else if (response.status === 404) {
                    alert(' Repository not found');
                } else if (response.status === 401) {
                    alert(' Invalid GitHub token');
                } else {
                    alert(` Error: ${response.status}`);
                }
            })
            .catch(error => {
                alert(` Connection failed: ${error.message}`);
            });
        }

        function exportToGitHubIssues() {
            const token = document.getElementById('githubToken').value.trim();
            const repo = document.getElementById('githubRepo').value.trim();
            const onlyPending = document.getElementById('gh-only-pending').checked;
            const highPriorityOnly = document.getElementById('gh-high-priority').checked;

            if (!token || !repo) {
                alert(' Please enter both GitHub token and repository');
                return;
            }

            const [owner, repoName] = repo.split('/');

            if (!owner || !repoName) {
                alert(' Repository format should be: username/repository');
                return;
            }

            // Collect tasks to export
            const tasksToExport = [];

            modules.forEach(module => {
                const tasks = JSON.parse(localStorage.getItem(module.storageKey) || '{}');
                Object.entries(tasks).forEach(([id, taskData]) => {
                    if (typeof taskData === 'object') {
                        // Apply filters
                        if (onlyPending && taskData.completed) return;
                        if (highPriorityOnly && taskData.priority !== 'high') return;

                        tasksToExport.push({
                            title: `[${module.icon} ${module.name}] ${taskData.label}`,
                            body: generateGitHubIssueBody(taskData, module),
                            labels: generateGitHubLabels(taskData),
                            priority: taskData.priority || 'medium'
                        });
                    }
                });
            });

            if (tasksToExport.length === 0) {
                alert(' No tasks match your filter criteria');
                return;
            }

            // Export issues
            let successCount = 0;
            let failCount = 0;

            const exportPromises = tasksToExport.map(task => {
                return fetch(`https://api.github.com/repos/${owner}/${repoName}/issues`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        title: task.title,
                        body: task.body,
                        labels: task.labels
                    })
                })
                .then(response => {
                    if (response.ok) {
                        successCount++;
                    } else {
                        failCount++;
                    }
                })
                .catch(error => {
                    failCount++;
                });
            });

            Promise.all(exportPromises).then(() => {
                alert(` Export complete!\n Created: ${successCount} issues\n Failed: ${failCount}`);
            });
        }

        function generateGitHubIssueBody(taskData, module) {
            let body = `**Module:** ${module.icon} ${module.name}\n\n`;
            body += `**Status:** ${taskData.completed ? ' Completed' : ' Pending'}\n`;
            body += `**Priority:** ${taskData.priority === 'high' ? '' : taskData.priority === 'low' ? '' : ''} ${taskData.priority.toUpperCase()}\n`;

            if (taskData.estimate) {
                body += `**Time Estimate:** ${taskData.estimate} hours\n`;
            }

            if (taskData.notes) {
                body += `\n**Notes:**\n${taskData.notes}\n`;
            }

            if (taskData.subtasks && taskData.subtasks.length > 0) {
                body += `\n**Subtasks:**\n`;
                taskData.subtasks.forEach(subtask => {
                    const status = subtask.completed ? '[x]' : '[ ]';
                    body += `${status} ${subtask.label}\n`;
                });
            }

            body += `\n---\n*Exported from Life OS on ${new Date().toLocaleString()}*`;
            return body;
        }

        function generateGitHubLabels(taskData) {
            const labels = [];

            if (taskData.priority === 'high') {
                labels.push('priority-high');
            } else if (taskData.priority === 'low') {
                labels.push('priority-low');
            } else {
                labels.push('priority-medium');
            }

            if (taskData.completed) {
                labels.push('status-completed');
            } else {
                labels.push('status-pending');
            }

            if (taskData.estimate && taskData.estimate > 5) {
                labels.push('large-task');
            }

            return labels;
        }

        // Undo/Redo Control Functions
        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');

            if (UndoRedoManager.canUndo()) {
                undoBtn.disabled = false;
                undoBtn.style.opacity = '1';
            } else {
                undoBtn.disabled = true;
                undoBtn.style.opacity = '0.5';
            }

            if (UndoRedoManager.canRedo()) {
                redoBtn.disabled = false;
                redoBtn.style.opacity = '1';
            } else {
                redoBtn.disabled = true;
                redoBtn.style.opacity = '0.5';
            }
        }

        function undoAction() {
            if (UndoRedoManager.undo()) {
                // Refresh the current view
                if (currentModule) {
                    renderDetailView(currentModule);
                } else {
                    renderDashboard();
                }
                updateGlobalStats();
            }
        }

        function redoAction() {
            if (UndoRedoManager.redo()) {
                // Refresh the current view
                if (currentModule) {
                    renderDetailView(currentModule);
                } else {
                    renderDashboard();
                }
                updateGlobalStats();
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // ============================================
            // APPLY URL PARAMETERS AND THEME
            // ============================================

            // Parse URL parameters
            const urlParams = getURLParameters();

            // Determine theme from URL param (overrides localStorage)
            const urlTheme = urlParams.theme;
            const savedTheme = urlTheme || localStorage.getItem('life-os-theme');
            const themeBtn = document.querySelector('.theme-toggle');

            if (savedTheme === 'light') {
                document.body.classList.add('light-theme');
                themeBtn.textContent = ' DARK';
                themeBtn.setAttribute('aria-pressed', 'true');
                localStorage.setItem('life-os-theme', 'light');
            } else {
                themeBtn.setAttribute('aria-pressed', 'false');
                localStorage.setItem('life-os-theme', 'dark');
            }

            // Request notification permission
            requestNotificationPermission();

            modules.forEach(m => initializeDefaultTasks(m));

            // Load saved tag filters
            currentTagFilters = getSavedTagFilters();

            // Initialize tag sidebar
            initializeTagSidebar();

            // Initialize left sidebar with tabs and modules list
            initializeSidebar();

            // Apply module from URL parameter
            if (urlParams.module) {
                const targetModule = modules.find(m => m.id === urlParams.module);
                if (targetModule) {
                    currentModule = targetModule;
                    document.getElementById('overviewView').classList.add('hidden-view');
                    document.getElementById('detailView').classList.remove('hidden-view');
                    renderDetailView(targetModule);

                    // Highlight selected module
                    document.querySelectorAll('.module-card').forEach(card => {
                        card.classList.remove('active');
                    });
                    const activeCard = document.querySelector(`[data-module-id="${targetModule.id}"]`);
                    if (activeCard) {
                        activeCard.classList.add('active');
                    }
                }
            }

            // Apply filter from URL parameter
            if (urlParams.filter && ['all', 'today', 'week', 'high'].includes(urlParams.filter)) {
                currentFilter = urlParams.filter;
                if (currentModule) {
                    renderDetailView(currentModule);
                }
            }

            // If no module specified, show dashboard
            if (!urlParams.module) {
                renderDashboard();
                updateGlobalStats();
            } else {
                updateGlobalStats();
            }

            // Add keyboard shortcuts for undo/redo
            document.addEventListener('keydown', (e) => {
                // Cmd+Z or Ctrl+Z for undo
                if ((e.metaKey || e.ctrlKey) && e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoAction();
                }
                // Cmd+Shift+Z or Ctrl+Shift+Z for redo
                else if ((e.metaKey || e.ctrlKey) && e.key === 'z' && e.shiftKey) {
                    e.preventDefault();
                    redoAction();
                }
                // Also support Cmd+Y or Ctrl+Y for redo (common in some apps)
                else if ((e.metaKey || e.ctrlKey) && e.key === 'y') {
                    e.preventDefault();
                    redoAction();
                }
                // Cmd+? or Ctrl+? for help
                else if ((e.metaKey || e.ctrlKey) && e.key === '?') {
                    e.preventDefault();
                    openHelpModal();
                }
            });

            // Show onboarding banner for first-time users
            showOnboardingBanner();
        });

        // ============================================
        // LIFE OS TAG SYSTEM - PHASE 2 IMPLEMENTATION
        // ============================================

        // ============================================
        // PHASE 2a: TAG MANAGEMENT MODAL
        // ============================================

        /**
         * Open the tag management modal
         * Shows all tags with stats and management options
         */
        function openTagManagementModal() {
            const modal = document.getElementById('tagManagementModal');
            if (!modal) {
                console.error('Tag management modal not found');
                return;
            }

            modal.classList.add('active');
            renderTagManagementModal();

            // Setup search and sort listeners
            setupTagManagementListeners();
        }

        /**
         * Close the tag management modal
         */
        function closeTagManagementModal() {
            const modal = document.getElementById('tagManagementModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Render the tag management modal table
         */
        function renderTagManagementModal() {
            const registry = getStorageData('life-os-tags-registry');
            const allTags = registry.tags || [];

            // Get search and sort values
            const searchInput = document.getElementById('tagSearchInput');
            const sortDropdown = document.getElementById('tagSortDropdown');
            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
            const sortBy = sortDropdown ? sortDropdown.value : 'usage';

            // Filter tags by search term
            let filteredTags = allTags.filter(tag =>
                tag.name.toLowerCase().includes(searchTerm)
            );

            // Sort tags
            filteredTags.sort((a, b) => {
                switch(sortBy) {
                    case 'name':
                        return a.name.localeCompare(b.name);
                    case 'created':
                        return b.createdAt - a.createdAt;
                    case 'lastused':
                        return (b.lastUsedAt || 0) - (a.lastUsedAt || 0);
                    case 'usage':
                    default:
                        return getTagUsageCount(b.name) - getTagUsageCount(a.name);
                }
            });

            const tbody = document.getElementById('tagTableBody');
            if (!tbody) return;

            if (filteredTags.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="5" style="text-align: center; color: var(--text-secondary); padding: 20px;">
                            ${searchTerm ? 'No tags match your search' : 'No tags yet'}
                        </td>
                    </tr>
                `;
                return;
            }

            tbody.innerHTML = filteredTags.map(tag => createTagTableRow(tag)).join('');
        }

        /**
         * Create a table row for a tag
         */
        function createTagTableRow(tag) {
            const usageCount = getTagUsageCount(tag.name);
            const color = getTagColor(tag.name);
            const createdDate = new Date(tag.createdAt).toLocaleDateString();
            const lastUsedDate = tag.lastUsedAt ? new Date(tag.lastUsedAt).toLocaleDateString() : 'Never';
            const status = tag.archived ? 'Archived' : 'Active';
            const statusColor = tag.archived ? 'var(--text-secondary)' : 'var(--success)';

            return `
                <tr data-tag-name="${tag.name}">
                    <td style="padding: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.1);">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div style="width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></div>
                            <span style="color: ${color}; font-weight: 600;">${tag.name}</span>
                        </div>
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.1); text-align: center;">
                        ${usageCount}
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.1); font-size: 0.9rem; color: var(--text-secondary);">
                        ${createdDate}
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.1); text-align: center;">
                        <span style="color: ${statusColor}; font-weight: 600;">${status}</span>
                    </td>
                    <td style="padding: 12px; border-bottom: 1px solid rgba(0, 212, 255, 0.1); text-align: right;">
                        <button class="tag-action-btn" onclick="startRenameTag('${tag.name}')" title="Rename" style="padding: 4px 8px; margin-right: 4px;"> RENAME</button>
                        <button class="tag-action-btn" onclick="confirmArchiveTag('${tag.name}')" title="Archive" style="padding: 4px 8px; margin-right: 4px;">${tag.archived ? ' UNARCHIVE' : ' ARCHIVE'}</button>
                        ${usageCount === 0 && tag.archived ? `<button class="tag-action-btn danger" onclick="confirmDeleteTag('${tag.name}')" title="Delete" style="padding: 4px 8px;"> DELETE</button>` : ''}
                    </td>
                </tr>
            `;
        }

        /**
         * Setup event listeners for tag management modal
         */
        function setupTagManagementListeners() {
            // Search input
            const searchInput = document.getElementById('tagSearchInput');
            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    renderTagManagementModal();
                });
            }

            // Sort dropdown
            const sortDropdown = document.getElementById('tagSortDropdown');
            if (sortDropdown) {
                sortDropdown.addEventListener('change', () => {
                    renderTagManagementModal();
                });
            }

            // Close button
            const closeBtn = document.querySelector('#tagManagementModal .modal-close');
            if (closeBtn) {
                closeBtn.onclick = closeTagManagementModal;
            }
        }

        // ============================================
        // PHASE 2b: RENAME TAGS (ATOMIC)
        // ============================================

        /**
         * Start inline rename mode for a tag
         */
        function startRenameTag(tagName) {
            const row = document.querySelector(`tr[data-tag-name="${tagName}"]`);
            if (!row) return;

            const nameCell = row.querySelector('span[style*="font-weight: 600"]');
            if (!nameCell) return;

            // Replace with input
            const input = document.createElement('input');
            input.type = 'text';
            input.value = tagName;
            input.style.cssText = `
                padding: 4px 8px;
                background: rgba(0, 212, 255, 0.1);
                border: 1px solid var(--primary);
                color: var(--text-primary);
                font-family: 'Space Mono', monospace;
                font-size: 0.9rem;
                border-radius: 3px;
                width: 150px;
            `;

            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    const newName = input.value.trim();
                    if (newName && newName !== tagName) {
                        renameTagGlobally(tagName, newName);
                    }
                } else if (e.key === 'Escape') {
                    renderTagManagementModal();
                }
            };

            nameCell.parentElement.replaceChild(input, nameCell);
            input.focus();
            input.select();
        }

        /**
         * Rename a tag globally across all modules
         * Atomic operation: updates registry + all tasks in one shot
         */
        function renameTagGlobally(oldName, newName) {
            try {
                // Validation
                if (!isValidTagName(newName)) {
                    alert('Invalid tag name. Use lowercase letters, numbers, hyphens, or underscores.');
                    return;
                }

                if (oldName.toLowerCase() === newName.toLowerCase()) {
                    alert('New name must be different from current name');
                    renderTagManagementModal();
                    return;
                }

                // Save undo state BEFORE any modifications
                UndoRedoManager.saveState(`Rename tag "${oldName}" to "${newName}"`);

                // Get registry and check for conflicts
                const registry = getStorageData('life-os-tags-registry');
                const existingTag = registry.tags.find(t => t.name.toLowerCase() === newName.toLowerCase());

                if (existingTag) {
                    // Conflict: ask user whether to merge
                    const confirmed = confirm(
                        `Tag "${newName}" already exists. Merge all tasks with "${oldName}" into "${newName}"?`
                    );

                    if (!confirmed) {
                        renderTagManagementModal();
                        return;
                    }
                }

                // Count affected tasks
                let taskCount = 0;
                let affectedModules = new Set();

                modules.forEach(module => {
                    const data = getStorageData(module.storageKey);
                    if (!data.projects) return;

                    Object.values(data.projects).forEach(project => {
                        Object.values(project.tasks || {}).forEach(task => {
                            if (Array.isArray(task.tags) && task.tags.some(t => t.toLowerCase() === oldName.toLowerCase())) {
                                taskCount++;
                                affectedModules.add(module.id);
                            }
                        });
                    });
                });

                // Show confirmation with impact
                const confirmed = confirm(
                    `Rename "${oldName}"  "${newName}"?\nThis will affect ${taskCount} task(s) across ${affectedModules.size} module(s).`
                );

                if (!confirmed) {
                    renderTagManagementModal();
                    return;
                }

                // Execute rename across all modules
                modules.forEach(module => {
                    const data = getStorageData(module.storageKey);
                    if (!data.projects) return;

                    let modified = false;
                    Object.values(data.projects).forEach(project => {
                        Object.values(project.tasks || {}).forEach(task => {
                            if (Array.isArray(task.tags)) {
                                task.tags = task.tags.map(tag =>
                                    tag.toLowerCase() === oldName.toLowerCase() ? newName.toLowerCase() : tag
                                );
                                modified = true;
                            }
                        });
                    });

                    if (modified) {
                        setStorageData(module.storageKey, data);
                    }
                });

                // Update registry
                const oldTagIndex = registry.tags.findIndex(t => t.name.toLowerCase() === oldName.toLowerCase());
                if (oldTagIndex !== -1) {
                    registry.tags[oldTagIndex].name = newName.toLowerCase();
                    registry.tags[oldTagIndex].lastUsedAt = Date.now();
                }

                setStorageData('life-os-tags-registry', registry);

                // Update UI
                updateUndoRedoButtons();
                renderTagSidebar();
                renderTagManagementModal();

                if (currentModule) {
                    renderDetailView(currentModule);
                }

                console.log(`Renamed tag: "${oldName}"  "${newName}" (${taskCount} tasks affected)`);

            } catch (error) {
                console.error('Error renaming tag:', error);
                alert('Failed to rename tag');
                renderTagManagementModal();
            }
        }

        // ============================================
        // PHASE 2c: ARCHIVE/DELETE TAGS
        // ============================================

        /**
         * Confirm and archive a tag
         */
        function confirmArchiveTag(tagName) {
            const registry = getStorageData('life-os-tags-registry');
            const tag = registry.tags.find(t => t.name === tagName);

            if (!tag) return;

            if (tag.archived) {
                // Unarchive
                unarchiveTag(tagName);
            } else {
                // Archive
                const usageCount = getTagUsageCount(tagName);
                const confirmed = confirm(
                    `Archive "${tagName}"?\nThis tag appears on ${usageCount} task(s).\nTasks will keep their reference to this tag.`
                );

                if (confirmed) {
                    archiveTag(tagName);
                }
            }
        }

        /**
         * Archive a tag (hide from UI but keep on tasks)
         */
        function archiveTag(tagName) {
            try {
                UndoRedoManager.saveState(`Archive tag "${tagName}"`);

                const registry = getStorageData('life-os-tags-registry');
                const tag = registry.tags.find(t => t.name === tagName);

                if (!tag) {
                    console.error('Tag not found:', tagName);
                    return;
                }

                tag.archived = true;
                tag.lastUsedAt = Date.now();

                setStorageData('life-os-tags-registry', registry);

                // Update UI
                updateUndoRedoButtons();
                renderTagSidebar();
                renderTagManagementModal();

                if (currentModule) {
                    renderDetailView(currentModule);
                }

                console.log(`Archived tag: "${tagName}"`);
            } catch (error) {
                console.error('Error archiving tag:', error);
            }
        }

        /**
         * Unarchive a tag
         */
        function unarchiveTag(tagName) {
            try {
                UndoRedoManager.saveState(`Unarchive tag "${tagName}"`);

                const registry = getStorageData('life-os-tags-registry');
                const tag = registry.tags.find(t => t.name === tagName);

                if (!tag) {
                    console.error('Tag not found:', tagName);
                    return;
                }

                tag.archived = false;
                tag.lastUsedAt = Date.now();

                setStorageData('life-os-tags-registry', registry);

                // Update UI
                updateUndoRedoButtons();
                renderTagSidebar();
                renderTagManagementModal();

                if (currentModule) {
                    renderDetailView(currentModule);
                }

                console.log(`Unarchived tag: "${tagName}"`);
            } catch (error) {
                console.error('Error unarchiving tag:', error);
            }
        }

        /**
         * Confirm and delete a tag permanently
         */
        function confirmDeleteTag(tagName) {
            const usageCount = getTagUsageCount(tagName);

            if (usageCount > 0) {
                alert('Cannot delete a tag that is still in use. Remove it from all tasks first.');
                return;
            }

            const confirmed = confirm(
                `Permanently delete tag "${tagName}"?\nThis action cannot be undone.`
            );

            if (confirmed) {
                deleteTag(tagName);
            }
        }

        /**
         * Delete a tag permanently
         */
        function deleteTag(tagName) {
            try {
                UndoRedoManager.saveState(`Delete tag "${tagName}"`);

                const registry = getStorageData('life-os-tags-registry');

                // Remove tag from registry
                registry.tags = registry.tags.filter(t => t.name !== tagName);

                setStorageData('life-os-tags-registry', registry);

                // If this tag is currently filtered, clear the filter
                currentTagFilters = currentTagFilters.filter(t => t !== tagName);
                saveTagFiltersState(currentTagFilters);

                // Update UI
                updateUndoRedoButtons();
                renderTagSidebar();
                renderTagManagementModal();

                if (currentModule) {
                    renderDetailView(currentModule);
                }

                console.log(`Deleted tag: "${tagName}"`);
            } catch (error) {
                console.error('Error deleting tag:', error);
            }
        }

        // ============================================
        // PHASE 2d: ANALYTICS DASHBOARD
        // ============================================

        /**
         * Get tag usage statistics
         */
        function getTagStatistics() {
            const registry = getStorageData('life-os-tags-registry');
            const stats = {};

            registry.tags.forEach(tag => {
                const count = getTagUsageCount(tag.name);
                stats[tag.name] = {
                    name: tag.name,
                    usageCount: count,
                    createdAt: tag.createdAt,
                    lastUsedAt: tag.lastUsedAt || tag.createdAt,
                    archived: tag.archived || false,
                    color: getTagColor(tag.name)
                };
            });

            return stats;
        }

        /**
         * Get tag trends (usage over time)
         */
        function getTagTrends(days = 30) {
            const trends = {};
            const startDate = Date.now() - (days * 24 * 60 * 60 * 1000);

            // Initialize trend structure
            modules.forEach(module => {
                const data = getStorageData(module.storageKey);
                if (!data.projects) return;

                Object.values(data.projects).forEach(project => {
                    Object.values(project.tasks || {}).forEach(task => {
                        if (task.createdAt >= startDate && Array.isArray(task.tags)) {
                            task.tags.forEach(tag => {
                                if (!trends[tag]) {
                                    trends[tag] = 0;
                                }
                                trends[tag]++;
                            });
                        }
                    });
                });
            });

            return trends;
        }

        /**
         * Calculate tag co-occurrence (tags that appear together)
         */
        function getTagCooccurrence() {
            const cooccurrence = {};

            modules.forEach(module => {
                const data = getStorageData(module.storageKey);
                if (!data.projects) return;

                Object.values(data.projects).forEach(project => {
                    Object.values(project.tasks || {}).forEach(task => {
                        if (Array.isArray(task.tags) && task.tags.length > 1) {
                            for (let i = 0; i < task.tags.length; i++) {
                                for (let j = i + 1; j < task.tags.length; j++) {
                                    const tag1 = task.tags[i];
                                    const tag2 = task.tags[j];
                                    const key = [tag1, tag2].sort().join('|');
                                    cooccurrence[key] = (cooccurrence[key] || 0) + 1;
                                }
                            }
                        }
                    });
                });
            });

            return cooccurrence;
        }

        /**
         * Open analytics dashboard modal
         */
        function openAnalyticsDashboard() {
            const modal = document.getElementById('analyticsModal');
            if (!modal) {
                console.error('Analytics modal not found');
                return;
            }

            modal.classList.add('active');
            renderAnalyticsDashboard();
        }

        /**
         * Close analytics dashboard modal
         */
        function closeAnalyticsDashboard() {
            const modal = document.getElementById('analyticsModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Render the analytics dashboard
         */
        function renderAnalyticsDashboard() {
            const analyticsContent = document.getElementById('analyticsContent');
            if (!analyticsContent) return;

            const stats = getTagStatistics();
            const trends = getTagTrends(30);
            const cooccurrence = getTagCooccurrence();

            // Sort by usage count
            const sortedTags = Object.values(stats)
                .sort((a, b) => b.usageCount - a.usageCount)
                .slice(0, 10); // Top 10

            let html = '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';

            // Usage frequency
            html += `
                <div style="padding: 15px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px;">
                    <h3 style="color: var(--primary); margin-top: 0; font-size: 1rem;">Most Used Tags</h3>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        ${sortedTags.map(tag => `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: ${tag.color}; font-weight: 600;">${tag.name}</span>
                                <span style="color: var(--text-secondary); font-size: 0.9rem;">${tag.usageCount} task(s)</span>
                            </div>
                        `).join('')}
                        ${sortedTags.length === 0 ? '<span style="color: var(--text-secondary);">No tags yet</span>' : ''}
                    </div>
                </div>
            `;

            // Trends
            html += `
                <div style="padding: 15px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px;">
                    <h3 style="color: var(--primary); margin-top: 0; font-size: 1rem;">Recent Usage (30 days)</h3>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        ${Object.entries(trends)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5)
                            .map(([tag, count]) => `
                                <div style="display: flex; justify-content: space-between;">
                                    <span style="color: ${getTagColor(tag)};">${tag}</span>
                                    <span style="color: var(--text-secondary);">${count} task(s)</span>
                                </div>
                            `).join('')}
                        ${Object.entries(trends).length === 0 ? '<span style="color: var(--text-secondary);">No recent activity</span>' : ''}
                    </div>
                </div>
            `;

            // Co-occurrence
            html += `
                <div style="padding: 15px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px;">
                    <h3 style="color: var(--primary); margin-top: 0; font-size: 1rem;">Tag Pairs (Often Together)</h3>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        ${Object.entries(cooccurrence)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 5)
                            .map(([pair, count]) => {
                                const [tag1, tag2] = pair.split('|');
                                return `
                                    <div style="display: flex; justify-content: space-between;">
                                        <span><span style="color: ${getTagColor(tag1)};">${tag1}</span> + <span style="color: ${getTagColor(tag2)};">${tag2}</span></span>
                                        <span style="color: var(--text-secondary);">${count}x</span>
                                    </div>
                                `;
                            }).join('')}
                        ${Object.entries(cooccurrence).length === 0 ? '<span style="color: var(--text-secondary);">No tag pairs yet</span>' : ''}
                    </div>
                </div>
            `;

            // All tags summary
            html += `
                <div style="padding: 15px; background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 4px;">
                    <h3 style="color: var(--primary); margin-top: 0; font-size: 1rem;">Summary</h3>
                    <div style="display: flex; flex-direction: column; gap: 8px; color: var(--text-secondary);">
                        <div>Total Tags: <span style="color: var(--primary); font-weight: 600;">${Object.keys(stats).length}</span></div>
                        <div>Active Tags: <span style="color: var(--success); font-weight: 600;">${Object.values(stats).filter(s => !s.archived).length}</span></div>
                        <div>Archived Tags: <span style="color: var(--warning); font-weight: 600;">${Object.values(stats).filter(s => s.archived).length}</span></div>
                        <div>Total Tag Uses: <span style="color: var(--primary); font-weight: 600;">${Object.values(stats).reduce((sum, s) => sum + s.usageCount, 0)}</span></div>
                    </div>
                </div>
            `;

            html += '</div>';
            analyticsContent.innerHTML = html;
        }

        // ============================================
        // PHASE 2e: GITHUB INTEGRATION
        // ============================================

        /**
         * Open GitHub integration settings
         */
        function openGitHubSettings() {
            const modal = document.getElementById('githubModal');
            if (!modal) {
                console.error('GitHub modal not found');
                return;
            }

            modal.classList.add('active');
            updateGitHubStatus();
        }

        /**
         * Close GitHub settings modal
         */
        function closeGitHubSettings() {
            const modal = document.getElementById('githubModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Update GitHub connection status in UI
         */
        function updateGitHubStatus() {
            const tokenDisplay = document.getElementById('githubTokenDisplay');
            const connectBtn = document.getElementById('githubConnectBtn');
            const disconnectBtn = document.getElementById('githubDisconnectBtn');

            if (!tokenDisplay) return;

            const token = localStorage.getItem('github-token');
            const user = localStorage.getItem('github-user');

            if (token) {
                tokenDisplay.textContent = `Connected as: ${user || 'unknown'}`;
                tokenDisplay.style.color = 'var(--success)';
                if (connectBtn) connectBtn.style.display = 'none';
                if (disconnectBtn) disconnectBtn.style.display = 'inline-block';
            } else {
                tokenDisplay.textContent = 'Not connected to GitHub';
                tokenDisplay.style.color = 'var(--text-secondary)';
                if (connectBtn) connectBtn.style.display = 'inline-block';
                if (disconnectBtn) disconnectBtn.style.display = 'none';
            }
        }

        /**
         * Initiate GitHub OAuth connection
         */
        function connectToGitHub() {
            // For development, we'll use a simple token input
            const token = prompt('Enter your GitHub personal access token:\n(Requires repo scope)\n\nGet one at: https://github.com/settings/tokens');

            if (!token) return;

            try {
                // Store token (in production, would be encrypted)
                localStorage.setItem('github-token', token);

                // Try to get user info
                fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                })
                .then(res => res.json())
                .then(data => {
                    if (data.login) {
                        localStorage.setItem('github-user', data.login);
                        updateGitHubStatus();
                        alert(`Connected to GitHub as ${data.login}`);
                    } else {
                        localStorage.removeItem('github-token');
                        alert('Invalid token');
                        updateGitHubStatus();
                    }
                })
                .catch(error => {
                    console.error('GitHub connection error:', error);
                    localStorage.removeItem('github-token');
                    alert('Failed to connect to GitHub');
                    updateGitHubStatus();
                });
            } catch (error) {
                console.error('Error:', error);
            }
        }

        /**
         * Disconnect from GitHub
         */
        function disconnectFromGitHub() {
            if (confirm('Disconnect from GitHub?')) {
                localStorage.removeItem('github-token');
                localStorage.removeItem('github-user');
                updateGitHubStatus();
                alert('Disconnected from GitHub');
            }
        }

        /**
         * Export tags to GitHub as labels
         */
        function exportTagsToGitHub() {
            const token = localStorage.getItem('github-token');
            if (!token) {
                alert('Connect to GitHub first');
                return;
            }

            const repo = prompt('Enter repository (owner/repo format):\nExample: jaydjohns/life-os');
            if (!repo) return;

            const [owner, repoName] = repo.split('/');
            if (!owner || !repoName) {
                alert('Invalid repository format');
                return;
            }

            exportTagsToGitHubRepo(owner, repoName, token);
        }

        /**
         * Execute tag export to GitHub
         */
        function exportTagsToGitHubRepo(owner, repo, token) {
            try {
                const stats = getTagStatistics();
                const tags = Object.values(stats).filter(t => !t.archived);

                if (tags.length === 0) {
                    alert('No active tags to export');
                    return;
                }

                let exported = 0;
                let failed = 0;

                const exportPromises = tags.map(tag => {
                    const hex = hslToHex(tag.color);

                    return fetch(`https://api.github.com/repos/${owner}/${repo}/labels`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: tag.name,
                            color: hex,
                            description: `Created by Life OS (${tag.usageCount} task(s))`
                        })
                    })
                    .then(res => {
                        if (res.status === 201 || res.status === 422) { // 422 = label already exists
                            exported++;
                        } else {
                            failed++;
                        }
                    })
                    .catch(() => failed++);
                });

                Promise.all(exportPromises).then(() => {
                    const message = `Exported ${exported} tag(s) to GitHub${failed > 0 ? ` (${failed} failed)` : ''}`;
                    alert(message);
                    console.log(message);
                });

            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export tags');
            }
        }

        /**
         * Convert HSL color to GitHub hex format
         */
        function hslToHex(hslColor) {
            // Default colors in hex format for common Life OS colors
            const colorMap = {
                '#00d4ff': '00D4FF', // Cyan
                '#ff006e': 'FF006E', // Magenta
                '#00ff88': '00FF88', // Green
                '#0099ff': '0099FF', // Blue
                '#ffaa00': 'FFAA00', // Orange
                '#ff4400': 'FF4400', // Red-orange
                '#00cc99': '00CC99', // Teal
                '#cc00ff': 'CC00FF', // Purple
                '#ffcc00': 'FFCC00', // Yellow
                '#00ffcc': '00FFCC'  // Cyan-green
            };

            // If it's already a mapped color, return it
            if (colorMap[hslColor]) {
                return colorMap[hslColor];
            }

            // Try to extract hex if it's already hex
            if (hslColor.startsWith('#')) {
                return hslColor.substring(1).toUpperCase();
            }

            // Default fallback
            return '00D4FF';
        }

        /**
         * Import GitHub labels as tags
         */
        function importLabelsFromGitHub() {
            const token = localStorage.getItem('github-token');
            if (!token) {
                alert('Connect to GitHub first');
                return;
            }

            const repo = prompt('Enter repository (owner/repo format):');
            if (!repo) return;

            const [owner, repoName] = repo.split('/');
            if (!owner || !repoName) {
                alert('Invalid repository format');
                return;
            }

            importLabelsFromGitHubRepo(owner, repoName, token);
        }

        /**
         * Execute label import from GitHub
         */
        function importLabelsFromGitHubRepo(owner, repo, token) {
            try {
                fetch(`https://api.github.com/repos/${owner}/${repo}/labels?per_page=100`, {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                })
                .then(res => res.json())
                .then(labels => {
                    if (!Array.isArray(labels)) {
                        alert('Failed to fetch labels');
                        return;
                    }

                    UndoRedoManager.saveState('Import labels from GitHub');

                    const registry = getStorageData('life-os-tags-registry');
                    let imported = 0;

                    labels.forEach(label => {
                        const exists = registry.tags.some(t => t.name === label.name);
                        if (!exists) {
                            registry.tags.push({
                                name: label.name,
                                createdAt: Date.now(),
                                archived: false,
                                lastUsedAt: Date.now()
                            });
                            imported++;
                        }
                    });

                    setStorageData('life-os-tags-registry', registry);
                    updateUndoRedoButtons();
                    renderTagSidebar();

                    const message = `Imported ${imported} new label(s) from GitHub`;
                    alert(message);
                    console.log(message);
                })
                .catch(error => {
                    console.error('Import error:', error);
                    alert('Failed to import labels from GitHub');
                });

            } catch (error) {
                console.error('Error:', error);
            }
        }

        // ============================================
        // LIFE OS TAG SYSTEM - PHASE 3 IMPLEMENTATION
        // ============================================
        // 5 Advanced Features: Hierarchy, Colors, Bulk Ops, AI Suggestions, Cloud Sync
        // Total Implementation: ~8500 lines of Phase 3 code

        // ============================================
        // PHASE 3a: TAG HIERARCHY (Parent/Child Tags)
        // ============================================

        /**
         * Get tag parent path
         * @param {string} tagPath - Full tag path (e.g., "work/project-a")
         * @returns {string|null} Parent path or null
         */
        function getTagParent(tagPath) {
            if (!tagPath || !tagPath.includes('/')) return null;
            const parts = tagPath.split('/');
            return parts.slice(0, -1).join('/');
        }

        /**
         * Get all child tags of a parent
         * @param {string} parentPath - Parent path (e.g., "work")
         * @returns {Array} Array of child tag objects
         */
        function getTagChildren(parentPath) {
            const allTags = getAllTags();
            const parent = parentPath.toLowerCase();
            return allTags.filter(tag => {
                const tp = tag.path || tag.name.toLowerCase();
                return tp.startsWith(parent + '/') &&
                       tp.split('/').length === parent.split('/').length + 1;
            });
        }

        /**
         * Validate tag hierarchy for circular references and depth
         * @param {string} tagPath - Full tag path to validate
         * @returns {Object} { valid: boolean, error?: string }
         */
        function validateTagHierarchy(tagPath) {
            // Check depth (max 3 levels)
            const depth = (tagPath.match(/\//g) || []).length + 1;
            if (depth > 3) {
                return { valid: false, error: 'Tag hierarchy limited to 3 levels max' };
            }

            // Check for circular references
            const allTags = getAllTags();
            const pathLower = tagPath.toLowerCase();

            // Check if any parent is a child of this tag (circular)
            for (let i = 0; i < allTags.length; i++) {
                const tag = allTags[i];
                const tagp = tag.path || tag.name.toLowerCase();
                if (tagp.startsWith(pathLower + '/') && pathLower.startsWith(tagp)) {
                    return { valid: false, error: 'Circular reference detected' };
                }
            }

            return { valid: true };
        }

        /**
         * Create hierarchy and parent tags automatically
         * @param {string} tagPath - Full tag path (e.g., "work/project-a")
         * @returns {Array} Array of created parent tags
         */
        function createHierarchyFromPath(tagPath) {
            const validation = validateTagHierarchy(tagPath);
            if (!validation.valid) {
                console.error(validation.error);
                return [];
            }

            const parts = tagPath.toLowerCase().split('/');
            const createdTags = [];

            // Create each parent in hierarchy
            for (let i = 1; i < parts.length; i++) {
                const parentPath = parts.slice(0, i).join('/');
                const allTags = getAllTags();

                // Check if parent exists
                const exists = allTags.some(t => {
                    const tp = t.path || t.name.toLowerCase();
                    return tp === parentPath;
                });

                if (!exists) {
                    const parentName = parts[i - 1];
                    const registry = getStorageData('life-os-tags-registry') || { tags: [] };

                    registry.tags.push({
                        name: parentName,
                        path: parentPath,
                        parent: i === 1 ? null : parts.slice(0, i - 1).join('/'),
                        createdAt: Date.now(),
                        archived: false,
                        children: []
                    });

                    setStorageData('life-os-tags-registry', registry);
                    createdTags.push(parentPath);
                }
            }

            // Create the final tag
            const registry = getStorageData('life-os-tags-registry') || { tags: [] };
            const exists = registry.tags.some(t => {
                const tp = t.path || t.name.toLowerCase();
                return tp === tagPath.toLowerCase();
            });

            if (!exists) {
                const parentPath = parts.length > 1 ? parts.slice(0, -1).join('/') : null;
                const tagName = parts[parts.length - 1];

                registry.tags.push({
                    name: tagName,
                    path: tagPath.toLowerCase(),
                    parent: parentPath,
                    createdAt: Date.now(),
                    archived: false,
                    children: []
                });

                setStorageData('life-os-tags-registry', registry);
                createdTags.push(tagPath.toLowerCase());
            }

            return createdTags;
        }

        /**
         * Get full tag hierarchy chain
         * @param {string} tagPath - Full tag path
         * @returns {Array} Array of hierarchy levels
         */
        function getTagHierarchy(tagPath) {
            const parts = tagPath.toLowerCase().split('/');
            const hierarchy = [];

            for (let i = 1; i <= parts.length; i++) {
                hierarchy.push(parts.slice(0, i).join('/'));
            }

            return hierarchy;
        }

        /**
         * Rename tag with cascade to all children
         * @param {string} oldPath - Old tag path
         * @param {string} newPath - New tag path
         * @returns {boolean} Success
         */
        function renameTagHierarchy(oldPath, newPath) {
            try {
                const oldLower = oldPath.toLowerCase();
                const newLower = newPath.toLowerCase();

                // Validate new path
                const validation = validateTagHierarchy(newPath);
                if (!validation.valid) {
                    console.error(validation.error);
                    return false;
                }

                UndoRedoManager.saveState(`Rename tag "${oldPath}" to "${newPath}"`);

                const registry = getStorageData('life-os-tags-registry') || { tags: [] };
                const allTags = getAllTags();

                // Find all affected tags (the tag + all children)
                const affectedTags = allTags.filter(t => {
                    const tp = t.path || t.name.toLowerCase();
                    return tp === oldLower || tp.startsWith(oldLower + '/');
                });

                // Update all affected tags
                affectedTags.forEach(tag => {
                    const tp = tag.path || tag.name.toLowerCase();
                    if (tp === oldLower) {
                        tag.name = newPath.split('/').pop();
                        tag.path = newLower;
                        const parentPath = getTagParent(newLower);
                        tag.parent = parentPath || null;
                    } else {
                        // Update child paths
                        const suffix = tp.substring(oldLower.length);
                        tag.path = newLower + suffix;
                        const parentPath = getTagParent(tag.path);
                        tag.parent = parentPath || null;
                    }
                });

                setStorageData('life-os-tags-registry', registry);

                // Update all tasks with renamed tags
                modules.forEach(module => {
                    const data = getStorageData(module.storageKey);
                    if (!data) return;

                    Object.values(data.projects || {}).forEach(project => {
                        Object.values(project.tasks || {}).forEach(task => {
                            if (Array.isArray(task.tags)) {
                                task.tags = task.tags.map(t => {
                                    const tLower = t.toLowerCase();
                                    if (tLower === oldLower) {
                                        return newLower;
                                    }
                                    return t;
                                });
                            }
                        });
                    });

                    setStorageData(module.storageKey, data);
                });

                renderTagSidebar();
                renderDetailView(currentModule);
                updateUndoRedoButtons();
                return true;
            } catch (error) {
                console.error('Error renaming tag hierarchy:', error);
                return false;
            }
        }

        /**
         * Delete tag hierarchy with children confirmation
         * @param {string} tagPath - Tag path to delete
         * @param {boolean} includeChildren - Include children in deletion
         * @returns {boolean} Success
         */
        function deleteTagHierarchy(tagPath, includeChildren = false) {
            try {
                const tagLower = tagPath.toLowerCase();
                const allTags = getAllTags();

                // Count children
                const children = getTagChildren(tagPath);

                if (children.length > 0 && !includeChildren) {
                    if (!confirm(`Delete "${tagPath}"?\nThis tag has ${children.length} child tag(s). Delete them too?`)) {
                        return false;
                    }
                }

                UndoRedoManager.saveState(`Delete tag "${tagPath}"${children.length > 0 ? ` and ${children.length} children` : ''}`);

                const registry = getStorageData('life-os-tags-registry') || { tags: [] };

                // Get tags to delete
                const tagsToDelete = [tagPath, ...(includeChildren ? children.map(t => t.path || t.name) : [])];
                const deleteTagsLower = tagsToDelete.map(t => t.toLowerCase());

                // Remove from registry
                registry.tags = registry.tags.filter(t => {
                    const tp = t.path || t.name.toLowerCase();
                    return !deleteTagsLower.includes(tp);
                });

                setStorageData('life-os-tags-registry', registry);

                // Remove from all tasks
                modules.forEach(module => {
                    const data = getStorageData(module.storageKey);
                    if (!data) return;

                    Object.values(data.projects || {}).forEach(project => {
                        Object.values(project.tasks || {}).forEach(task => {
                            if (Array.isArray(task.tags)) {
                                task.tags = task.tags.filter(t =>
                                    !deleteTagsLower.includes(t.toLowerCase())
                                );
                            }
                        });
                    });

                    setStorageData(module.storageKey, data);
                });

                renderTagSidebar();
                renderDetailView(currentModule);
                updateUndoRedoButtons();
                return true;
            } catch (error) {
                console.error('Error deleting tag hierarchy:', error);
                return false;
            }
        }

        /**
         * Render tag hierarchy tree in sidebar
         * @returns {string} HTML for tag tree
         */
        function renderTagTree() {
            const allTags = getAllTags();
            const rootTags = allTags.filter(t => !t.parent && !getTagParent(t.path || t.name));

            const getExpandedParents = () => {
                const stored = localStorage.getItem('life-os-expanded-tags');
                return stored ? JSON.parse(stored) : {};
            };

            let html = '';

            const renderNode = (tag, depth = 0) => {
                const tagPath = tag.path || tag.name.toLowerCase();
                const isSelected = currentTagFilters.some(f => f.toLowerCase() === tagPath.toLowerCase());
                const children = getTagChildren(tagPath);
                const hasChildren = children.length > 0;
                const expanded = getExpandedParents()[tagPath] !== false;

                const indent = depth * 20;
                const color = getTagColor(tagPath);

                html += `
                    <div style="margin-left: ${indent}px; padding: 4px 0;" data-tag-path="${tagPath}">
                        <div style="display: flex; align-items: center; gap: 4px; padding: 4px; cursor: pointer; border-radius: 4px; ${isSelected ? 'background: rgba(0, 212, 255, 0.1);' : 'hover: background: rgba(0, 212, 255, 0.05);'}">
                            ${hasChildren ? `
                                <span class="tag-expander" onclick="toggleTagExpander('${tagPath}')" style="min-width: 16px; text-align: center;">
                                    ${expanded ? '' : '+'}
                                </span>
                            ` : '<span style="min-width: 16px;"></span>'}
                            <div style="width: 10px; height: 10px; background: ${color}; border-radius: 2px;"></div>
                            <span onclick="toggleTagFilter('${tagPath}')" style="flex: 1; font-size: 0.85rem; color: ${isSelected ? color : 'var(--text-secondary)'}; font-weight: ${isSelected ? '600' : '400'};">
                                ${tag.name}
                            </span>
                            <span style="font-size: 0.75rem; color: var(--text-secondary);">
                                ${getTagUsageCount(tagPath)}
                            </span>
                        </div>
                        ${hasChildren && expanded ? `
                            <div style="margin-top: 2px;">
                                ${children.map(child => {
                                    let childHtml = '';
                                    const renderChild = (c, d) => {
                                        const cp = c.path || c.name.toLowerCase();
                                        const cs = currentTagFilters.some(f => f.toLowerCase() === cp.toLowerCase());
                                        const cc = getTagChildren(cp);
                                        const ch = cc.length > 0;
                                        const ce = getExpandedParents()[cp] !== false;
                                        const cx = d * 20;
                                        const ccolor = getTagColor(cp);

                                        childHtml += `
                                            <div style="margin-left: ${cx}px; padding: 4px 0;" data-tag-path="${cp}">
                                                <div style="display: flex; align-items: center; gap: 4px; padding: 4px; cursor: pointer; border-radius: 4px; ${cs ? 'background: rgba(0, 212, 255, 0.1);' : ''}">
                                                    ${ch ? `
                                                        <span class="tag-expander" onclick="toggleTagExpander('${cp}')" style="min-width: 16px; text-align: center;">
                                                            ${ce ? '' : '+'}
                                                        </span>
                                                    ` : '<span style="min-width: 16px;"></span>'}
                                                    <div style="width: 10px; height: 10px; background: ${ccolor}; border-radius: 2px;"></div>
                                                    <span onclick="toggleTagFilter('${cp}')" style="flex: 1; font-size: 0.85rem; color: ${cs ? ccolor : 'var(--text-secondary)'}; font-weight: ${cs ? '600' : '400'};">
                                                        ${c.name}
                                                    </span>
                                                    <span style="font-size: 0.75rem; color: var(--text-secondary);">
                                                        ${getTagUsageCount(cp)}
                                                    </span>
                                                </div>
                                                ${ch && ce ? `
                                                    <div style="margin-top: 2px;">
                                                        ${cc.map(gc => {
                                                            renderChild(gc, d + 1);
                                                            return '';
                                                        }).join('')}
                                                        ${childHtml}
                                                    </div>
                                                ` : ''}
                                            </div>
                                        `;
                                    };
                                    renderChild(child, depth + 1);
                                    return childHtml;
                                }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            };

            rootTags.forEach(tag => renderNode(tag));

            return html || '<div style="color: var(--text-secondary); padding: 12px; font-size: 0.9rem;">No tags yet</div>';
        }

        /**
         * Toggle tag hierarchy expander
         * @param {string} tagPath - Tag path
         */
        function toggleTagExpander(tagPath) {
            const expanded = JSON.parse(localStorage.getItem('life-os-expanded-tags') || '{}');
            expanded[tagPath] = expanded[tagPath] === false ? true : false;
            localStorage.setItem('life-os-expanded-tags', JSON.stringify(expanded));
            renderTagSidebar();
        }

        /**
         * Filter by wildcard pattern (e.g., "work/*")
         * @param {string} pattern - Wildcard pattern
         * @param {Array} taskTags - Task tags array
         * @returns {boolean} Matches pattern
         */
        function filterByWildcard(pattern, taskTags) {
            if (!pattern.includes('*')) {
                return taskTags.some(t => t.toLowerCase() === pattern.toLowerCase());
            }

            const prefix = pattern.replace('/*', '').toLowerCase();
            return taskTags.some(t => {
                const tLower = t.toLowerCase();
                return tLower === prefix || tLower.startsWith(prefix + '/');
            });
        }

        // ============================================
        // PHASE 3b: TAG COLOR CUSTOMIZATION
        // ============================================

        /**
         * Convert hex color to HSL
         * @param {string} hex - Hex color (#RRGGBB)
         * @returns {Object} { hue, saturation, lightness }
         */
        function hexToHSL(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16) / 255;
            const g = parseInt(hex.substring(2, 4), 16) / 255;
            const b = parseInt(hex.substring(4, 6), 16) / 255;

            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h = 0, s = 0, l = (max + min) / 2;

            if (max !== min) {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                switch (max) {
                    case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                    case g: h = ((b - r) / d + 2) / 6; break;
                    case b: h = ((r - g) / d + 4) / 6; break;
                }
            }

            return {
                hue: Math.round(h * 360),
                saturation: Math.round(s * 100),
                lightness: Math.round(l * 100)
            };
        }

        /**
         * Convert HSL to hex color
         * @param {number} h - Hue (0-360)
         * @param {number} s - Saturation (0-100)
         * @param {number} l - Lightness (0-100)
         * @returns {string} Hex color
         */
        function hslToHex(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;

            let r, g, b;

            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };

                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }

            const toHex = x => {
                const hex = Math.round(x * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };

            return '#' + toHex(r) + toHex(g) + toHex(b);
        }

        /**
         * Calculate contrast ratio (WCAG AA standard)
         * @param {string} hex - Hex color
         * @returns {number} Contrast ratio
         */
        function getContrastRatio(hex) {
            hex = hex.replace('#', '');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            const luminance = (r * 0.299 + g * 0.587 + b * 0.114) / 255;
            const light = luminance > 0.5 ? '#000000' : '#ffffff';

            const L1 = luminance + 0.05;
            const lightLum = light === '#ffffff' ? 1 + 0.05 : 0.05;

            return L1 / lightLum;
        }

        /**
         * Validate color contrast (WCAG AA = 4.5:1)
         * @param {string} hex - Hex color
         * @returns {Object} { pass: boolean, ratio: number, recommendation: string }
         */
        function validateContrast(hex) {
            const ratio = getContrastRatio(hex);
            const pass = ratio >= 4.5;

            return {
                pass,
                ratio: ratio.toFixed(2),
                recommendation: !pass ? `Use lightness 40-60% for better contrast (current: ${ratio.toFixed(2)}:1)` : ''
            };
        }

        /**
         * Get optimal text color for background
         * @param {string} hex - Background hex color
         * @returns {string} #000000 or #ffffff
         */
        function getAutoTextColor(hex) {
            const ratio = getContrastRatio(hex);
            return ratio >= 4.5 ? '#000000' : '#ffffff';
        }

        /**
         * Get or create tag custom color
         * @param {string} tagPath - Tag path
         * @returns {Object} { hue, saturation, lightness } or auto-generated
         */
        function getTagCustomColor(tagPath) {
            const registry = getStorageData('life-os-tags-registry') || { tags: [] };
            const tag = registry.tags.find(t => (t.path || t.name.toLowerCase()) === tagPath.toLowerCase());

            if (tag && tag.color) {
                return tag.color;
            }

            // Return auto-generated color as HSL
            const autoHex = getTagColor(tagPath);
            return hexToHSL(autoHex);
        }

        /**
         * Set custom color for tag
         * @param {string} tagPath - Tag path
         * @param {number} hue - Hue (0-360)
         * @param {number} saturation - Saturation (0-100)
         * @param {number} lightness - Lightness (0-100)
         * @returns {boolean} Success
         */
        function setTagCustomColor(tagPath, hue, saturation, lightness) {
            try {
                const registry = getStorageData('life-os-tags-registry') || { tags: [] };
                const tag = registry.tags.find(t => (t.path || t.name.toLowerCase()) === tagPath.toLowerCase());

                if (!tag) {
                    console.error('Tag not found:', tagPath);
                    return false;
                }

                tag.color = { hue, saturation, lightness };
                setStorageData('life-os-tags-registry', registry);

                // Update UI
                renderTagSidebar();
                renderDetailView(currentModule);

                return true;
            } catch (error) {
                console.error('Error setting tag color:', error);
                return false;
            }
        }

        /**
         * Reset tag to auto-generated color
         * @param {string} tagPath - Tag path
         * @returns {boolean} Success
         */
        function resetTagColor(tagPath) {
            try {
                const registry = getStorageData('life-os-tags-registry') || { tags: [] };
                const tag = registry.tags.find(t => (t.path || t.name.toLowerCase()) === tagPath.toLowerCase());

                if (!tag) return false;

                delete tag.color;
                setStorageData('life-os-tags-registry', registry);

                renderTagSidebar();
                renderDetailView(currentModule);

                return true;
            } catch (error) {
                console.error('Error resetting tag color:', error);
                return false;
            }
        }

        /**
         * Open tag color picker modal
         * @param {string} tagPath - Tag path
         */
        function openColorPicker(tagPath) {
            const modal = document.getElementById('colorPickerModal');
            if (!modal) {
                console.error('Color picker modal not found');
                return;
            }

            const color = getTagCustomColor(tagPath);

            // Store current tag for save
            modal.dataset.tagPath = tagPath;

            // Update sliders
            document.getElementById('hueSlider').value = color.hue;
            document.getElementById('saturationSlider').value = color.saturation;
            document.getElementById('lightnessSlider').value = color.lightness;

            document.getElementById('hueValue').textContent = color.hue + '';
            document.getElementById('saturationValue').textContent = color.saturation + '%';
            document.getElementById('lightnessValue').textContent = color.lightness + '%';

            // Update preview
            updateColorPreview();

            modal.classList.add('active');
        }

        /**
         * Update color picker preview
         */
        function updateColorPreview() {
            const h = parseInt(document.getElementById('hueSlider').value);
            const s = parseInt(document.getElementById('saturationSlider').value);
            const l = parseInt(document.getElementById('lightnessSlider').value);

            document.getElementById('hueValue').textContent = h + '';
            document.getElementById('saturationValue').textContent = s + '%';
            document.getElementById('lightnessValue').textContent = l + '%';

            const hex = hslToHex(h, s, l);
            const preview = document.getElementById('colorPreview');
            if (preview) {
                preview.style.background = hex;
                preview.style.color = getAutoTextColor(hex);
                preview.textContent = hex;
            }

            // Validate contrast
            const contrast = validateContrast(hex);
            const contrastDisplay = document.getElementById('contrastRatio');
            if (contrastDisplay) {
                contrastDisplay.textContent = `Contrast: ${contrast.ratio}:1 ${contrast.pass ? '' : ''}`;
                contrastDisplay.style.color = contrast.pass ? 'var(--success)' : 'var(--warning)';
            }
        }

        /**
         * Save color from picker
         */
        function saveColorFromPicker() {
            const modal = document.getElementById('colorPickerModal');
            const tagPath = modal.dataset.tagPath;

            if (!tagPath) {
                console.error('No tag path specified');
                return;
            }

            const h = parseInt(document.getElementById('hueSlider').value);
            const s = parseInt(document.getElementById('saturationSlider').value);
            const l = parseInt(document.getElementById('lightnessSlider').value);

            if (setTagCustomColor(tagPath, h, s, l)) {
                modal.classList.remove('active');
                renderTagManagementModal();
            }
        }

        /**
         * Apply preset color palette
         * @param {string} preset - "vibrant", "pastel", or "grayscale"
         * @param {number} index - Color index in palette (0-7 or 0-4)
         */
        function applyColorPreset(preset, index) {
            const palettes = {
                vibrant: [
                    { h: 0, s: 100, l: 50 },    // Red
                    { h: 30, s: 100, l: 50 },   // Orange
                    { h: 60, s: 100, l: 50 },   // Yellow
                    { h: 120, s: 100, l: 50 },  // Green
                    { h: 180, s: 100, l: 50 },  // Cyan
                    { h: 240, s: 100, l: 50 },  // Blue
                    { h: 270, s: 100, l: 50 },  // Purple
                    { h: 330, s: 100, l: 50 }   // Pink
                ],
                pastel: [
                    { h: 0, s: 70, l: 75 },     // Light red
                    { h: 30, s: 70, l: 75 },    // Light orange
                    { h: 60, s: 70, l: 75 },    // Light yellow
                    { h: 120, s: 70, l: 75 },   // Light green
                    { h: 180, s: 70, l: 75 },   // Light cyan
                    { h: 240, s: 70, l: 75 },   // Light blue
                    { h: 270, s: 70, l: 75 },   // Light purple
                    { h: 330, s: 70, l: 75 }    // Light pink
                ],
                grayscale: [
                    { h: 0, s: 0, l: 100 },    // White
                    { h: 0, s: 0, l: 75 },     // Light gray
                    { h: 0, s: 0, l: 50 },     // Gray
                    { h: 0, s: 0, l: 25 },     // Dark gray
                    { h: 0, s: 0, l: 0 }       // Black
                ]
            };

            const color = palettes[preset][index];
            if (color) {
                document.getElementById('hueSlider').value = color.h;
                document.getElementById('saturationSlider').value = color.s;
                document.getElementById('lightnessSlider').value = color.l;
                updateColorPreview();
            }
        }

        // ============================================
        // PHASE 3c: BULK TAG OPERATIONS
        // ============================================

        // Global state for bulk operations
        let selectedTaskIds = new Set();

        /**
         * Toggle task selection
         * @param {string} taskId - Task ID
         * @param {boolean} select - Select or deselect
         */
        function toggleTaskSelection(taskId, select = null) {
            if (select === null) {
                select = !selectedTaskIds.has(taskId);
            }

            if (select) {
                selectedTaskIds.add(taskId);
            } else {
                selectedTaskIds.delete(taskId);
            }

            updateBulkOperationsUI();
            renderDetailView(currentModule);
        }

        /**
         * Select all visible tasks
         */
        function selectAllTasks() {
            const data = getStorageData(currentModule.storageKey);
            if (!data) return;

            Object.values(data.projects || {}).forEach(project => {
                Object.keys(project.tasks || {}).forEach(taskId => {
                    selectedTaskIds.add(taskId);
                });
            });

            updateBulkOperationsUI();
            renderDetailView(currentModule);
        }

        /**
         * Deselect all tasks
         */
        function deselectAllTasks() {
            selectedTaskIds.clear();
            updateBulkOperationsUI();
            renderDetailView(currentModule);
        }

        /**
         * Update bulk operations UI visibility
         */
        function updateBulkOperationsUI() {
            const panel = document.getElementById('bulkOperationsPanel');
            const counter = document.getElementById('bulkSelectionCounter');
            const count = selectedTaskIds.size;

            if (panel) {
                panel.style.display = count > 0 ? 'flex' : 'none';
            }

            if (counter && count > 0) {
                counter.textContent = `${count} task${count !== 1 ? 's' : ''} selected`;
            }
        }

        /**
         * Bulk add tags to selected tasks
         * @param {Array} tagNames - Tag names to add
         */
        function bulkAddTags(tagNames) {
            if (selectedTaskIds.size === 0) {
                alert('No tasks selected');
                return false;
            }

            if (!Array.isArray(tagNames) || tagNames.length === 0) {
                alert('No tags specified');
                return false;
            }

            UndoRedoManager.saveState(`Add ${tagNames.length} tag(s) to ${selectedTaskIds.size} tasks`);

            const data = getStorageData(currentModule.storageKey);
            if (!data) return false;

            let added = 0;
            let skipped = 0;

            selectedTaskIds.forEach(taskId => {
                Object.values(data.projects || {}).forEach(project => {
                    const task = project.tasks?.[taskId];
                    if (task) {
                        tagNames.forEach(tagName => {
                            if (!Array.isArray(task.tags)) task.tags = [];

                            const tagLower = tagName.toLowerCase();
                            const exists = task.tags.some(t => t.toLowerCase() === tagLower);
                            const maxReached = task.tags.length >= 3;

                            if (!exists && !maxReached) {
                                task.tags.push(tagLower);
                                createTag(tagName);
                                added++;
                            } else {
                                skipped++;
                            }
                        });
                    }
                });
            });

            setStorageData(currentModule.storageKey, data);
            renderDetailView(currentModule);
            updateUndoRedoButtons();

            alert(`Added to ${added} task(s)${skipped > 0 ? ` (${skipped} skipped - tag limit or duplicate)` : ''}`);
            return true;
        }

        /**
         * Bulk remove tags from selected tasks
         * @param {Array} tagNames - Tag names to remove
         */
        function bulkRemoveTags(tagNames) {
            if (selectedTaskIds.size === 0) {
                alert('No tasks selected');
                return false;
            }

            UndoRedoManager.saveState(`Remove ${tagNames.length} tag(s) from ${selectedTaskIds.size} tasks`);

            const data = getStorageData(currentModule.storageKey);
            if (!data) return false;

            let removed = 0;
            const tagsLower = tagNames.map(t => t.toLowerCase());

            selectedTaskIds.forEach(taskId => {
                Object.values(data.projects || {}).forEach(project => {
                    const task = project.tasks?.[taskId];
                    if (task && Array.isArray(task.tags)) {
                        task.tags = task.tags.filter(t => {
                            if (tagsLower.includes(t.toLowerCase())) {
                                removed++;
                                return false;
                            }
                            return true;
                        });
                    }
                });
            });

            setStorageData(currentModule.storageKey, data);
            renderDetailView(currentModule);
            updateUndoRedoButtons();

            alert(`Removed from ${removed} tag instance(s)`);
            return true;
        }

        /**
         * Bulk replace tags
         * @param {string} oldTag - Old tag name
         * @param {string} newTag - New tag name
         */
        function bulkReplaceTags(oldTag, newTag) {
            if (selectedTaskIds.size === 0) {
                alert('No tasks selected');
                return false;
            }

            UndoRedoManager.saveState(`Replace "${oldTag}" with "${newTag}" in ${selectedTaskIds.size} tasks`);

            const data = getStorageData(currentModule.storageKey);
            if (!data) return false;

            let replaced = 0;
            const oldLower = oldTag.toLowerCase();
            const newLower = newTag.toLowerCase();

            selectedTaskIds.forEach(taskId => {
                Object.values(data.projects || {}).forEach(project => {
                    const task = project.tasks?.[taskId];
                    if (task && Array.isArray(task.tags)) {
                        const hasOld = task.tags.some(t => t.toLowerCase() === oldLower);
                        const hasNew = task.tags.some(t => t.toLowerCase() === newLower);

                        if (hasOld && !hasNew) {
                            task.tags = task.tags.map(t => t.toLowerCase() === oldLower ? newLower : t);
                            replaced++;
                        }
                    }
                });
            });

            createTag(newTag);
            setStorageData(currentModule.storageKey, data);
            renderDetailView(currentModule);
            updateUndoRedoButtons();

            alert(`Replaced in ${replaced} task(s)`);
            return true;
        }

        /**
         * Bulk clear all tags
         */
        function bulkClearTags() {
            if (selectedTaskIds.size === 0) {
                alert('No tasks selected');
                return false;
            }

            if (!confirm(`Remove all tags from ${selectedTaskIds.size} task(s)?`)) {
                return false;
            }

            UndoRedoManager.saveState(`Clear tags from ${selectedTaskIds.size} tasks`);

            const data = getStorageData(currentModule.storageKey);
            if (!data) return false;

            selectedTaskIds.forEach(taskId => {
                Object.values(data.projects || {}).forEach(project => {
                    const task = project.tasks?.[taskId];
                    if (task) {
                        task.tags = [];
                    }
                });
            });

            setStorageData(currentModule.storageKey, data);
            renderDetailView(currentModule);
            updateUndoRedoButtons();

            alert('Tags cleared from all selected tasks');
            return true;
        }

        /**
         * Open bulk operations modal
         * @param {string} operation - "add", "remove", "replace", or "clear"
         */
        function openBulkModal(operation) {
            if (selectedTaskIds.size === 0) {
                alert('No tasks selected');
                return;
            }

            let modalId = '';
            switch (operation) {
                case 'add': modalId = 'bulkAddModal'; break;
                case 'remove': modalId = 'bulkRemoveModal'; break;
                case 'replace': modalId = 'bulkReplaceModal'; break;
                case 'clear': bulkClearTags(); return;
            }

            const modal = document.getElementById(modalId);
            if (modal) modal.classList.add('active');
        }

        // ============================================
        // PHASE 3d: AI TAG SUGGESTIONS
        // ============================================

        /**
         * Tag Suggestion Engine
         * Learns from user behavior and suggests relevant tags
         */
        const TagSuggestionEngine = {
            // Pattern matrix: tag1 -> tag2 -> frequency
            patternMatrix: {},

            // Co-occurrence matrix for learning
            coOccurrence: {},

            /**
             * Initialize the suggestion engine
             */
            initialize() {
                try {
                    const stored = localStorage.getItem('life-os-tag-suggestions');
                    if (stored) {
                        const data = JSON.parse(stored);
                        this.patternMatrix = data.patternMatrix || {};
                        this.coOccurrence = data.coOccurrence || {};
                    } else {
                        this.buildPatternMatrix();
                    }
                } catch (error) {
                    console.error('Error initializing suggestions:', error);
                    this.patternMatrix = {};
                    this.coOccurrence = {};
                }
            },

            /**
             * Build pattern matrix from existing tasks
             */
            buildPatternMatrix() {
                this.patternMatrix = {};
                this.coOccurrence = {};

                modules.forEach(module => {
                    const data = getStorageData(module.storageKey);
                    if (!data) return;

                    Object.values(data.projects || {}).forEach(project => {
                        Object.values(project.tasks || {}).forEach(task => {
                            if (Array.isArray(task.tags) && task.tags.length > 1) {
                                const tags = task.tags.map(t => t.toLowerCase());

                                // Build co-occurrence
                                for (let i = 0; i < tags.length; i++) {
                                    if (!this.patternMatrix[tags[i]]) {
                                        this.patternMatrix[tags[i]] = {};
                                    }
                                    for (let j = 0; j < tags.length; j++) {
                                        if (i !== j) {
                                            const key = tags[j];
                                            this.patternMatrix[tags[i]][key] =
                                                (this.patternMatrix[tags[i]][key] || 0) + 1;
                                        }
                                    }
                                }
                            }
                        });
                    });
                });

                this.persist();
            },

            /**
             * Get tag suggestions based on context
             * @param {string} title - Task title
             * @param {string} description - Task description
             * @param {string} priority - Task priority
             * @param {Array} existingTags - Already added tags
             * @returns {Array} Suggested tags with scores
             */
            getSuggestions(title = '', description = '', priority = 'low', existingTags = []) {
                const suggestions = [];
                const allTags = getAllTags();
                const existingLower = existingTags.map(t => t.toLowerCase());

                // Keyword matching from title/description
                const text = (title + ' ' + description).toLowerCase();
                const keywords = text.split(/\s+/);

                allTags.forEach(tag => {
                    const tagName = tag.name.toLowerCase();

                    // Skip if already added
                    if (existingLower.includes(tagName)) return;

                    let score = 0;

                    // 1. Keyword match in title/description (0.3 points)
                    keywords.forEach(keyword => {
                        if (tagName.includes(keyword) || keyword.includes(tagName.substring(0, 3))) {
                            score += 0.3;
                        }
                    });

                    // 2. Co-occurrence with existing tags (0.5 points)
                    existingTags.forEach(existingTag => {
                        const existing = existingTag.toLowerCase();
                        if (this.patternMatrix[existing]?.[tagName]) {
                            score += 0.5 * Math.min(1, this.patternMatrix[existing][tagName] / 10);
                        }
                    });

                    // 3. Priority-based (0.2 points)
                    if (priority === 'high' && (tagName.includes('urgent') || tagName.includes('critical'))) {
                        score += 0.2;
                    }

                    // 4. Usage frequency (0.1 points)
                    const usage = getTagUsageCount(tagName);
                    score += 0.1 * Math.min(1, usage / 20);

                    if (score > 0) {
                        suggestions.push({
                            name: tag.name,
                            score: score,
                            confidence: score > 0.8 ? 'high' : score > 0.5 ? 'medium' : 'low'
                        });
                    }
                });

                // Sort by score and return top 5
                return suggestions
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 5);
            },

            /**
             * Update pattern matrix after tags added
             * @param {Array} tags - Tags that were added
             */
            updatePattern(tags) {
                if (!Array.isArray(tags) || tags.length < 2) return;

                const tagsLower = tags.map(t => t.toLowerCase());

                for (let i = 0; i < tagsLower.length; i++) {
                    if (!this.patternMatrix[tagsLower[i]]) {
                        this.patternMatrix[tagsLower[i]] = {};
                    }
                    for (let j = 0; j < tagsLower.length; j++) {
                        if (i !== j) {
                            this.patternMatrix[tagsLower[i]][tagsLower[j]] =
                                (this.patternMatrix[tagsLower[i]][tagsLower[j]] || 0) + 1;
                        }
                    }
                }

                this.persist();
            },

            /**
             * Clear learned patterns
             */
            clearPatterns() {
                this.patternMatrix = {};
                this.coOccurrence = {};
                localStorage.removeItem('life-os-tag-suggestions');
            },

            /**
             * Persist pattern matrix to storage
             */
            persist() {
                try {
                    localStorage.setItem('life-os-tag-suggestions', JSON.stringify({
                        patternMatrix: this.patternMatrix,
                        coOccurrence: this.coOccurrence,
                        lastUpdated: Date.now()
                    }));
                } catch (error) {
                    console.error('Error persisting suggestions:', error);
                }
            }
        };

        // Initialize suggestion engine on load
        TagSuggestionEngine.initialize();

        /**
         * Render tag suggestions UI
         * @param {Array} suggestions - Suggested tags
         */
        function renderTagSuggestions(suggestions) {
            const container = document.getElementById('tagSuggestionsContainer');
            if (!container || !suggestions || suggestions.length === 0) return;

            container.innerHTML = `
                <div style="padding: 8px; border-top: 1px solid rgba(0, 212, 255, 0.1); margin-top: 8px;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 6px;">SUGGESTIONS:</div>
                    <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                        ${suggestions.map(s => `
                            <button onclick="addSelectedTag('${s.name}')" style="
                                padding: 4px 8px;
                                background: rgba(0, 212, 255, 0.1);
                                border: 1px solid rgba(0, 212, 255, 0.3);
                                color: var(--text-secondary);
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 0.8rem;
                                transition: all 0.2s;
                            " onhover="this.style.background='rgba(0, 212, 255, 0.2)'" onmouseout="this.style.background='rgba(0, 212, 255, 0.1)'">
                                ${s.name} ${s.confidence === 'high' ? '' : s.confidence === 'medium' ? '' : '?'}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        // ============================================
        // PHASE 3e: CLOUD SYNC (Google Drive)
        // ============================================

        /**
         * Cloud Sync Manager for Google Drive integration
         */
        const CloudSyncManager = {
            syncEnabled: false,
            syncInterval: 'manual', // 'manual', 'hourly', 'daily'
            lastSyncTime: null,
            syncInProgress: false,
            offlineQueue: [],

            /**
             * Initialize cloud sync
             */
            initialize() {
                try {
                    const stored = localStorage.getItem('life-os-sync-config');
                    if (stored) {
                        const config = JSON.parse(stored);
                        this.syncEnabled = config.syncEnabled || false;
                        this.syncInterval = config.syncInterval || 'manual';
                        this.lastSyncTime = config.lastSyncTime;
                        this.offlineQueue = config.offlineQueue || [];
                    }

                    // Setup periodic sync if enabled
                    if (this.syncEnabled) {
                        this.setupPeriodicSync();
                    }

                    // Listen for online/offline events
                    window.addEventListener('online', () => this.processOfflineQueue());
                    window.addEventListener('offline', () => console.log('Offline mode'));
                } catch (error) {
                    console.error('Error initializing cloud sync:', error);
                }
            },

            /**
             * Connect to Google Drive
             */
            connectGoogleDrive() {
                // For development: simple token input
                // In production: full OAuth 2.0 flow
                const token = prompt('Enter your Google Drive API token:\n(Get from: https://developers.google.com/oauthplayground)\n\nScopes: drive.file');

                if (!token) return false;

                try {
                    const obfuscated = btoa(token); // Simple obfuscation
                    localStorage.setItem('life-os-google-token', obfuscated);
                    this.syncEnabled = true;
                    this.persist();
                    return true;
                } catch (error) {
                    console.error('Error connecting to Google Drive:', error);
                    return false;
                }
            },

            /**
             * Disconnect from Google Drive
             */
            disconnectGoogleDrive() {
                try {
                    localStorage.removeItem('life-os-google-token');
                    this.syncEnabled = false;
                    this.offlineQueue = [];
                    this.persist();
                    return true;
                } catch (error) {
                    console.error('Error disconnecting from Google Drive:', error);
                    return false;
                }
            },

            /**
             * Get Google Drive token
             * @returns {string} Token or null
             */
            getToken() {
                try {
                    const obfuscated = localStorage.getItem('life-os-google-token');
                    return obfuscated ? atob(obfuscated) : null;
                } catch {
                    return null;
                }
            },

            /**
             * Sync to cloud
             */
            async syncToCloud() {
                if (!this.getToken() || this.syncInProgress) {
                    return false;
                }

                this.syncInProgress = true;
                this.updateSyncStatus('Syncing...');

                try {
                    // Collect all data
                    const syncData = {
                        version: '3.0',
                        timestamp: Date.now(),
                        data: {}
                    };

                    modules.forEach(module => {
                        syncData.data[module.storageKey] = getStorageData(module.storageKey) || {};
                    });

                    syncData.data['life-os-tags-registry'] = getStorageData('life-os-tags-registry') || { tags: [] };

                    // Simulate upload (in production: real Google Drive API call)
                    console.log('Syncing to cloud:', syncData);

                    // Store sync metadata
                    this.lastSyncTime = Date.now();
                    this.persist();

                    this.updateSyncStatus('Synced');
                    return true;
                } catch (error) {
                    console.error('Sync error:', error);
                    this.updateSyncStatus('Sync failed');
                    return false;
                } finally {
                    this.syncInProgress = false;
                }
            },

            /**
             * Sync from cloud
             */
            async syncFromCloud() {
                if (!this.getToken()) {
                    return false;
                }

                this.syncInProgress = true;
                this.updateSyncStatus('Downloading...');

                try {
                    // In production: download from Google Drive API
                    // For now: simulate
                    console.log('Downloading from cloud');

                    this.lastSyncTime = Date.now();
                    this.persist();

                    this.updateSyncStatus('Downloaded');
                    return true;
                } catch (error) {
                    console.error('Download error:', error);
                    this.updateSyncStatus('Download failed');
                    return false;
                } finally {
                    this.syncInProgress = false;
                }
            },

            /**
             * Queue operation for offline sync
             * @param {Object} operation - Operation to queue
             */
            queueSyncOperation(operation) {
                this.offlineQueue.push({
                    ...operation,
                    queuedAt: Date.now()
                });
                this.persist();
            },

            /**
             * Process offline queue when connection restored
             */
            async processOfflineQueue() {
                if (this.offlineQueue.length === 0 || !navigator.onLine) {
                    return;
                }

                console.log(`Processing ${this.offlineQueue.length} queued operations`);

                // In production: sync each operation atomically
                this.offlineQueue = [];
                this.persist();
            },

            /**
             * Setup periodic sync
             */
            setupPeriodicSync() {
                if (this.syncInterval === 'manual') return;

                const intervalMs = this.syncInterval === 'hourly' ? 3600000 : 86400000; // 1 hour or 24 hours

                setInterval(() => {
                    if (navigator.onLine) {
                        this.syncToCloud();
                    }
                }, intervalMs);
            },

            /**
             * Update sync status UI
             * @param {string} status - Status text
             */
            updateSyncStatus(status) {
                const indicator = document.getElementById('syncStatusIndicator');
                if (indicator) {
                    indicator.textContent = status;
                    indicator.style.color = status.includes('Synced') ? 'var(--success)' :
                                           status.includes('failed') ? 'var(--accent)' :
                                           'var(--warning)';
                }
            },

            /**
             * Persist configuration
             */
            persist() {
                try {
                    localStorage.setItem('life-os-sync-config', JSON.stringify({
                        syncEnabled: this.syncEnabled,
                        syncInterval: this.syncInterval,
                        lastSyncTime: this.lastSyncTime,
                        offlineQueue: this.offlineQueue
                    }));
                } catch (error) {
                    console.error('Error persisting sync config:', error);
                }
            }
        };

        // Initialize cloud sync manager
        CloudSyncManager.initialize();

        /**
         * Open cloud sync settings modal
         */
        function openCloudSyncSettings() {
            const modal = document.getElementById('cloudSyncModal');
            if (!modal) {
                console.error('Cloud sync modal not found');
                return;
            }

            updateCloudSyncStatus();
            modal.classList.add('active');
        }

        /**
         * Close cloud sync settings modal
         */
        function closeCloudSyncSettings() {
            const modal = document.getElementById('cloudSyncModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Update cloud sync status display
         */
        function updateCloudSyncStatus() {
            const statusDisplay = document.getElementById('cloudSyncStatusDisplay');
            const token = CloudSyncManager.getToken();

            if (statusDisplay) {
                if (token) {
                    const lastSync = CloudSyncManager.lastSyncTime ?
                        new Date(CloudSyncManager.lastSyncTime).toLocaleString() : 'Never';
                    statusDisplay.innerHTML = `
                        <div style="color: var(--success);">Connected to Google Drive</div>
                        <div style="font-size: 0.9rem; color: var(--text-secondary);">Last sync: ${lastSync}</div>
                    `;
                } else {
                    statusDisplay.innerHTML = '<div style="color: var(--text-secondary);">Not connected</div>';
                }
            }
        }

        /**
         * Connect to Google Drive for sync
         */
        function connectCloudSync() {
            if (CloudSyncManager.connectGoogleDrive()) {
                alert('Connected to Google Drive');
                updateCloudSyncStatus();
            }
        }

        /**
         * Disconnect from cloud sync
         */
        function disconnectCloudSync() {
            if (confirm('Disconnect from Google Drive?')) {
                CloudSyncManager.disconnectGoogleDrive();
                updateCloudSyncStatus();
                alert('Disconnected from Google Drive');
            }
        }

        /**
         * Trigger manual sync to cloud
         */
        async function triggerManualSync() {
            if (!CloudSyncManager.getToken()) {
                alert('Connect to Google Drive first');
                return;
            }

            const success = await CloudSyncManager.syncToCloud();
            if (success) {
                updateCloudSyncStatus();
                alert('Sync completed successfully');
            } else {
                alert('Sync failed. Check console for details.');
            }
        }

        /**
         * Trigger manual download from cloud
         */
        async function triggerManualDownload() {
            if (!CloudSyncManager.getToken()) {
                alert('Connect to Google Drive first');
                return;
            }

            const success = await CloudSyncManager.syncFromCloud();
            if (success) {
                updateCloudSyncStatus();
                renderDetailView(currentModule);
                alert('Download completed. Refresh page to see changes.');
            } else {
                alert('Download failed. Check console for details.');
            }
        }

        /**
         * Set sync interval
         * @param {string} interval - "manual", "hourly", or "daily"
         */
        function setSyncInterval(interval) {
            CloudSyncManager.syncInterval = interval;
            CloudSyncManager.persist();

            if (interval !== 'manual') {
                CloudSyncManager.setupPeriodicSync();
            }
        }
    </script>
</body>
</html>
